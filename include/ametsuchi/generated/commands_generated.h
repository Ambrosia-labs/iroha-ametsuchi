// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_
#define FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "key_generated.h"
#include "primitives_generated.h"

namespace iroha {

struct Add;

struct Remove;

struct Store;

struct Transfer;

struct AddAsset;

struct RemoveAsset;

struct CreateAsset;

struct Execute;

struct SetChaincode;

struct SetPeerTrust;

struct ChangePeerTrust;

struct SetPeerActive;

struct AddSignatory;

struct SetAccountsUseKeys;

enum class Object : uint8_t {
  NONE = 0,
  Peer = 1,
  Account = 2,
  Chaincode = 3,
  MIN = NONE,
  MAX = Chaincode
};

inline const char **EnumNamesObject() {
  static const char *names[] = {
    "NONE",
    "Peer",
    "Account",
    "Chaincode",
    nullptr
  };
  return names;
}

inline const char *EnumNameObject(Object e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObject()[index];
}

template<typename T> struct ObjectTraits {
  static const Object enum_value = Object::NONE;
};

template<> struct ObjectTraits<iroha::Peer> {
  static const Object enum_value = Object::Peer;
};

template<> struct ObjectTraits<iroha::Account> {
  static const Object enum_value = Object::Account;
};

template<> struct ObjectTraits<iroha::Chaincode> {
  static const Object enum_value = Object::Chaincode;
};

bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type);
bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AnyAsset : uint8_t {
  NONE = 0,
  Asset = 1,
  Currency = 2,
  MIN = NONE,
  MAX = Currency
};

inline const char **EnumNamesAnyAsset() {
  static const char *names[] = {
    "NONE",
    "Asset",
    "Currency",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyAsset(AnyAsset e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnyAsset()[index];
}

template<typename T> struct AnyAssetTraits {
  static const AnyAsset enum_value = AnyAsset::NONE;
};

template<> struct AnyAssetTraits<iroha::Asset> {
  static const AnyAsset enum_value = AnyAsset::Asset;
};

template<> struct AnyAssetTraits<iroha::Currency> {
  static const AnyAsset enum_value = AnyAsset::Currency;
};

bool VerifyAnyAsset(flatbuffers::Verifier &verifier, const void *obj, AnyAsset type);
bool VerifyAnyAssetVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

//////////////////////////////////////////
enum class Command : uint8_t {
  NONE = 0,
  AddAsset = 1,
  RemoveAsset = 2,
  CreateAsset = 3,
  Transfer = 4,
  Add = 5,
  Remove = 6,
  Execute = 7,
  Store = 8,
  SetPeerTrust = 9,
  ChangePeerTrust = 10,
  SetPeerActive = 11,
  SetChaincode = 12,
  MIN = NONE,
  MAX = SetChaincode
};

inline const char **EnumNamesCommand() {
  static const char *names[] = {
    "NONE",
    "AddAsset",
    "RemoveAsset",
    "CreateAsset",
    "Transfer",
    "Add",
    "Remove",
    "Execute",
    "Store",
    "SetPeerTrust",
    "ChangePeerTrust",
    "SetPeerActive",
    "SetChaincode",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command::NONE;
};

template<> struct CommandTraits<AddAsset> {
  static const Command enum_value = Command::AddAsset;
};

template<> struct CommandTraits<RemoveAsset> {
  static const Command enum_value = Command::RemoveAsset;
};

template<> struct CommandTraits<CreateAsset> {
  static const Command enum_value = Command::CreateAsset;
};

template<> struct CommandTraits<Transfer> {
  static const Command enum_value = Command::Transfer;
};

template<> struct CommandTraits<Add> {
  static const Command enum_value = Command::Add;
};

template<> struct CommandTraits<Remove> {
  static const Command enum_value = Command::Remove;
};

template<> struct CommandTraits<Execute> {
  static const Command enum_value = Command::Execute;
};

template<> struct CommandTraits<Store> {
  static const Command enum_value = Command::Store;
};

template<> struct CommandTraits<SetPeerTrust> {
  static const Command enum_value = Command::SetPeerTrust;
};

template<> struct CommandTraits<ChangePeerTrust> {
  static const Command enum_value = Command::ChangePeerTrust;
};

template<> struct CommandTraits<SetPeerActive> {
  static const Command enum_value = Command::SetPeerActive;
};

template<> struct CommandTraits<SetChaincode> {
  static const Command enum_value = Command::SetChaincode;
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const iroha::Peer *object_as_Peer() const {
    return (object_type() == Object::Peer)? static_cast<const iroha::Peer *>(object()) : nullptr;
  }
  const iroha::Account *object_as_Account() const {
    return (object_type() == Object::Account)? static_cast<const iroha::Account *>(object()) : nullptr;
  }
  const iroha::Chaincode *object_as_Chaincode() const {
    return (object_type() == Object::Chaincode)? static_cast<const iroha::Chaincode *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::Peer *Add::object_as<iroha::Peer>() const {
  return object_as_Peer();
}

template<> inline const iroha::Account *Add::object_as<iroha::Account>() const {
  return object_as_Account();
}

template<> inline const iroha::Chaincode *Add::object_as<iroha::Chaincode>() const {
  return object_as_Chaincode();
}

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Add::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Add::VT_OBJECT, object);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Add>(end);
    fbb_.Required(o, Add::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Remove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const iroha::Peer *object_as_Peer() const {
    return (object_type() == Object::Peer)? static_cast<const iroha::Peer *>(object()) : nullptr;
  }
  const iroha::Account *object_as_Account() const {
    return (object_type() == Object::Account)? static_cast<const iroha::Account *>(object()) : nullptr;
  }
  const iroha::Chaincode *object_as_Chaincode() const {
    return (object_type() == Object::Chaincode)? static_cast<const iroha::Chaincode *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::Peer *Remove::object_as<iroha::Peer>() const {
  return object_as_Peer();
}

template<> inline const iroha::Account *Remove::object_as<iroha::Account>() const {
  return object_as_Account();
}

template<> inline const iroha::Chaincode *Remove::object_as<iroha::Chaincode>() const {
  return object_as_Chaincode();
}

struct RemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Remove::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Remove::VT_OBJECT, object);
  }
  RemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveBuilder &operator=(const RemoveBuilder &);
  flatbuffers::Offset<Remove> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Remove>(end);
    fbb_.Required(o, Remove::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Remove> CreateRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  RemoveBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Store FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_DATA = 6
  };
  const iroha::PublicKey *accPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct StoreBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<iroha::PublicKey> accPubKey) {
    fbb_.AddOffset(Store::VT_ACCPUBKEY, accPubKey);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>>> data) {
    fbb_.AddOffset(Store::VT_DATA, data);
  }
  StoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StoreBuilder &operator=(const StoreBuilder &);
  flatbuffers::Offset<Store> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Store>(end);
    fbb_.Required(o, Store::VT_ACCPUBKEY);
    fbb_.Required(o, Store::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<Store> CreateStore(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>>> data = 0) {
  StoreBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Store> CreateStoreDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<iroha::KeyValueObject>> *data = nullptr) {
  return iroha::CreateStore(
      _fbb,
      accPubKey,
      data ? _fbb.CreateVector<flatbuffers::Offset<iroha::KeyValueObject>>(*data) : 0);
}

struct Transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENCY = 4,
    VT_SENDER = 6,
    VT_RECEIVER = 8
  };
  const iroha::Asset *currency() const {
    return GetPointer<const iroha::Asset *>(VT_CURRENCY);
  }
  const iroha::PublicKey *sender() const {
    return GetPointer<const iroha::PublicKey *>(VT_SENDER);
  }
  const iroha::PublicKey *receiver() const {
    return GetPointer<const iroha::PublicKey *>(VT_RECEIVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CURRENCY) &&
           verifier.VerifyTable(currency()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.VerifyTable(sender()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.VerifyTable(receiver()) &&
           verifier.EndTable();
  }
};

struct TransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency(flatbuffers::Offset<iroha::Asset> currency) {
    fbb_.AddOffset(Transfer::VT_CURRENCY, currency);
  }
  void add_sender(flatbuffers::Offset<iroha::PublicKey> sender) {
    fbb_.AddOffset(Transfer::VT_SENDER, sender);
  }
  void add_receiver(flatbuffers::Offset<iroha::PublicKey> receiver) {
    fbb_.AddOffset(Transfer::VT_RECEIVER, receiver);
  }
  TransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransferBuilder &operator=(const TransferBuilder &);
  flatbuffers::Offset<Transfer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Transfer>(end);
    fbb_.Required(o, Transfer::VT_CURRENCY);
    fbb_.Required(o, Transfer::VT_SENDER);
    fbb_.Required(o, Transfer::VT_RECEIVER);
    return o;
  }
};

inline flatbuffers::Offset<Transfer> CreateTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::Asset> currency = 0,
    flatbuffers::Offset<iroha::PublicKey> sender = 0,
    flatbuffers::Offset<iroha::PublicKey> receiver = 0) {
  TransferBuilder builder_(_fbb);
  builder_.add_receiver(receiver);
  builder_.add_sender(sender);
  builder_.add_currency(currency);
  return builder_.Finish();
}

//////////////////////////////////////////
/// Commands for Asset
struct AddAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET = 6
  };
  const iroha::PublicKey *accPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *asset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *>(VT_ASSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           verifier.VerifyVectorOfTables(asset()) &&
           verifier.EndTable();
  }
};

struct AddAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<iroha::PublicKey> accPubKey) {
    fbb_.AddOffset(AddAsset::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>>> asset) {
    fbb_.AddOffset(AddAsset::VT_ASSET, asset);
  }
  AddAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddAssetBuilder &operator=(const AddAssetBuilder &);
  flatbuffers::Offset<AddAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AddAsset>(end);
    fbb_.Required(o, AddAsset::VT_ACCPUBKEY);
    fbb_.Required(o, AddAsset::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<AddAsset> CreateAddAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>>> asset = 0) {
  AddAssetBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddAsset> CreateAddAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<iroha::Asset>> *asset = nullptr) {
  return iroha::CreateAddAsset(
      _fbb,
      accPubKey,
      asset ? _fbb.CreateVector<flatbuffers::Offset<iroha::Asset>>(*asset) : 0);
}

struct RemoveAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET = 6
  };
  const iroha::PublicKey *accPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *asset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *>(VT_ASSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           verifier.VerifyVectorOfTables(asset()) &&
           verifier.EndTable();
  }
};

struct RemoveAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<iroha::PublicKey> accPubKey) {
    fbb_.AddOffset(RemoveAsset::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>>> asset) {
    fbb_.AddOffset(RemoveAsset::VT_ASSET, asset);
  }
  RemoveAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveAssetBuilder &operator=(const RemoveAssetBuilder &);
  flatbuffers::Offset<RemoveAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RemoveAsset>(end);
    fbb_.Required(o, RemoveAsset::VT_ACCPUBKEY);
    fbb_.Required(o, RemoveAsset::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<RemoveAsset> CreateRemoveAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>>> asset = 0) {
  RemoveAssetBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveAsset> CreateRemoveAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<iroha::Asset>> *asset = nullptr) {
  return iroha::CreateRemoveAsset(
      _fbb,
      accPubKey,
      asset ? _fbb.CreateVector<flatbuffers::Offset<iroha::Asset>>(*asset) : 0);
}

struct CreateAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           verifier.EndTable();
  }
};

struct CreateAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(CreateAsset::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(CreateAsset::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(CreateAsset::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(CreateAsset::VT_DESCRIPTION, description);
  }
  CreateAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateAssetBuilder &operator=(const CreateAssetBuilder &);
  flatbuffers::Offset<CreateAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CreateAsset>(end);
    fbb_.Required(o, CreateAsset::VT_ASSET_NAME);
    fbb_.Required(o, CreateAsset::VT_DOMAIN_NAME);
    fbb_.Required(o, CreateAsset::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<CreateAsset> CreateCreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0) {
  CreateAssetBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateAsset> CreateCreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr) {
  return iroha::CreateCreateAsset(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0);
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Chaincode
struct Execute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8
  };
  const flatbuffers::String *code_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE_NAME) &&
           verifier.Verify(code_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           verifier.EndTable();
  }
};

struct ExecuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code_name(flatbuffers::Offset<flatbuffers::String> code_name) {
    fbb_.AddOffset(Execute::VT_CODE_NAME, code_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Execute::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Execute::VT_LEDGER_NAME, ledger_name);
  }
  ExecuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecuteBuilder &operator=(const ExecuteBuilder &);
  flatbuffers::Offset<Execute> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Execute>(end);
    fbb_.Required(o, Execute::VT_CODE_NAME);
    fbb_.Required(o, Execute::VT_DOMAIN_NAME);
    fbb_.Required(o, Execute::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Execute> CreateExecute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0) {
  ExecuteBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_code_name(code_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Execute> CreateExecuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr) {
  return iroha::CreateExecute(
      _fbb,
      code_name ? _fbb.CreateString(code_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0);
}

struct SetChaincode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAINCODE = 4
  };
  const iroha::Chaincode *chaincode() const {
    return GetPointer<const iroha::Chaincode *>(VT_CHAINCODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CHAINCODE) &&
           verifier.VerifyTable(chaincode()) &&
           verifier.EndTable();
  }
};

struct SetChaincodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chaincode(flatbuffers::Offset<iroha::Chaincode> chaincode) {
    fbb_.AddOffset(SetChaincode::VT_CHAINCODE, chaincode);
  }
  SetChaincodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetChaincodeBuilder &operator=(const SetChaincodeBuilder &);
  flatbuffers::Offset<SetChaincode> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SetChaincode>(end);
    fbb_.Required(o, SetChaincode::VT_CHAINCODE);
    return o;
  }
};

inline flatbuffers::Offset<SetChaincode> CreateSetChaincode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::Chaincode> chaincode = 0) {
  SetChaincodeBuilder builder_(_fbb);
  builder_.add_chaincode(chaincode);
  return builder_.Finish();
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Peer
struct SetPeerTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_TRUST = 6
  };
  const iroha::PublicKey *peerPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_PEERPUBKEY);
  }
  double trust() const {
    return GetField<double>(VT_TRUST, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<double>(verifier, VT_TRUST) &&
           verifier.EndTable();
  }
};

struct SetPeerTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<iroha::PublicKey> peerPubKey) {
    fbb_.AddOffset(SetPeerTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_trust(double trust) {
    fbb_.AddElement<double>(SetPeerTrust::VT_TRUST, trust, 0.0);
  }
  SetPeerTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPeerTrustBuilder &operator=(const SetPeerTrustBuilder &);
  flatbuffers::Offset<SetPeerTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SetPeerTrust>(end);
    fbb_.Required(o, SetPeerTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<SetPeerTrust> CreateSetPeerTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> peerPubKey = 0,
    double trust = 0.0) {
  SetPeerTrustBuilder builder_(_fbb);
  builder_.add_trust(trust);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

struct ChangePeerTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_DELTA = 6
  };
  const iroha::PublicKey *peerPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_PEERPUBKEY);
  }
  double delta() const {
    return GetField<double>(VT_DELTA, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<double>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct ChangePeerTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<iroha::PublicKey> peerPubKey) {
    fbb_.AddOffset(ChangePeerTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_delta(double delta) {
    fbb_.AddElement<double>(ChangePeerTrust::VT_DELTA, delta, 0.0);
  }
  ChangePeerTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangePeerTrustBuilder &operator=(const ChangePeerTrustBuilder &);
  flatbuffers::Offset<ChangePeerTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ChangePeerTrust>(end);
    fbb_.Required(o, ChangePeerTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<ChangePeerTrust> CreateChangePeerTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> peerPubKey = 0,
    double delta = 0.0) {
  ChangePeerTrustBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

struct SetPeerActive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_ACTIVE = 6
  };
  const iroha::PublicKey *peerPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_PEERPUBKEY);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           verifier.EndTable();
  }
};

struct SetPeerActiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<iroha::PublicKey> peerPubKey) {
    fbb_.AddOffset(SetPeerActive::VT_PEERPUBKEY, peerPubKey);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(SetPeerActive::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  SetPeerActiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPeerActiveBuilder &operator=(const SetPeerActiveBuilder &);
  flatbuffers::Offset<SetPeerActive> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SetPeerActive>(end);
    fbb_.Required(o, SetPeerActive::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<SetPeerActive> CreateSetPeerActive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> peerPubKey = 0,
    bool active = false) {
  SetPeerActiveBuilder builder_(_fbb);
  builder_.add_peerPubKey(peerPubKey);
  builder_.add_active(active);
  return builder_.Finish();
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Account
struct AddSignatory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4,
    VT_SIGNATORY = 6
  };
  const iroha::PublicKey *account() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCOUNT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *signatory() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *>(VT_SIGNATORY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.VerifyTable(account()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATORY) &&
           verifier.Verify(signatory()) &&
           verifier.VerifyVectorOfTables(signatory()) &&
           verifier.EndTable();
  }
};

struct AddSignatoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<iroha::PublicKey> account) {
    fbb_.AddOffset(AddSignatory::VT_ACCOUNT, account);
  }
  void add_signatory(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> signatory) {
    fbb_.AddOffset(AddSignatory::VT_SIGNATORY, signatory);
  }
  AddSignatoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddSignatoryBuilder &operator=(const AddSignatoryBuilder &);
  flatbuffers::Offset<AddSignatory> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AddSignatory>(end);
    fbb_.Required(o, AddSignatory::VT_ACCOUNT);
    fbb_.Required(o, AddSignatory::VT_SIGNATORY);
    return o;
  }
};

inline flatbuffers::Offset<AddSignatory> CreateAddSignatory(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> account = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> signatory = 0) {
  AddSignatoryBuilder builder_(_fbb);
  builder_.add_signatory(signatory);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddSignatory> CreateAddSignatoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> account = 0,
    const std::vector<flatbuffers::Offset<iroha::PublicKey>> *signatory = nullptr) {
  return iroha::CreateAddSignatory(
      _fbb,
      account,
      signatory ? _fbb.CreateVector<flatbuffers::Offset<iroha::PublicKey>>(*signatory) : 0);
}

struct SetAccountsUseKeys FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTS = 4,
    VT_USEKEYS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *accounts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *>(VT_ACCOUNTS);
  }
  uint16_t useKeys() const {
    return GetField<uint16_t>(VT_USEKEYS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNTS) &&
           verifier.Verify(accounts()) &&
           verifier.VerifyVectorOfTables(accounts()) &&
           VerifyField<uint16_t>(verifier, VT_USEKEYS) &&
           verifier.EndTable();
  }
};

struct SetAccountsUseKeysBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> accounts) {
    fbb_.AddOffset(SetAccountsUseKeys::VT_ACCOUNTS, accounts);
  }
  void add_useKeys(uint16_t useKeys) {
    fbb_.AddElement<uint16_t>(SetAccountsUseKeys::VT_USEKEYS, useKeys, 0);
  }
  SetAccountsUseKeysBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetAccountsUseKeysBuilder &operator=(const SetAccountsUseKeysBuilder &);
  flatbuffers::Offset<SetAccountsUseKeys> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SetAccountsUseKeys>(end);
    fbb_.Required(o, SetAccountsUseKeys::VT_ACCOUNTS);
    return o;
  }
};

inline flatbuffers::Offset<SetAccountsUseKeys> CreateSetAccountsUseKeys(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> accounts = 0,
    uint16_t useKeys = 0) {
  SetAccountsUseKeysBuilder builder_(_fbb);
  builder_.add_accounts(accounts);
  builder_.add_useKeys(useKeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetAccountsUseKeys> CreateSetAccountsUseKeysDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<iroha::PublicKey>> *accounts = nullptr,
    uint16_t useKeys = 0) {
  return iroha::CreateSetAccountsUseKeys(
      _fbb,
      accounts ? _fbb.CreateVector<flatbuffers::Offset<iroha::PublicKey>>(*accounts) : 0,
      useKeys);
}

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type) {
  switch (type) {
    case Object::NONE: {
      return true;
    }
    case Object::Peer: {
      auto ptr = reinterpret_cast<const iroha::Peer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object::Account: {
      auto ptr = reinterpret_cast<const iroha::Account *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object::Chaincode: {
      auto ptr = reinterpret_cast<const iroha::Chaincode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObject(
        verifier,  values->Get(i), types->GetEnum<Object>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyAsset(flatbuffers::Verifier &verifier, const void *obj, AnyAsset type) {
  switch (type) {
    case AnyAsset::NONE: {
      return true;
    }
    case AnyAsset::Asset: {
      auto ptr = reinterpret_cast<const iroha::Asset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAsset::Currency: {
      auto ptr = reinterpret_cast<const iroha::Currency *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyAssetVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyAsset(
        verifier,  values->Get(i), types->GetEnum<AnyAsset>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command::NONE: {
      return true;
    }
    case Command::AddAsset: {
      auto ptr = reinterpret_cast<const AddAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::RemoveAsset: {
      auto ptr = reinterpret_cast<const RemoveAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::CreateAsset: {
      auto ptr = reinterpret_cast<const CreateAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Transfer: {
      auto ptr = reinterpret_cast<const Transfer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Remove: {
      auto ptr = reinterpret_cast<const Remove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Execute: {
      auto ptr = reinterpret_cast<const Execute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Store: {
      auto ptr = reinterpret_cast<const Store *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::SetPeerTrust: {
      auto ptr = reinterpret_cast<const SetPeerTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::ChangePeerTrust: {
      auto ptr = reinterpret_cast<const ChangePeerTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::SetPeerActive: {
      auto ptr = reinterpret_cast<const SetPeerActive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::SetChaincode: {
      auto ptr = reinterpret_cast<const SetChaincode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_

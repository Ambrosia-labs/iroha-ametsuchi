// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_
#define FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "commands_generated.h"
#include "key_generated.h"
#include "primitives_generated.h"

namespace iroha {

struct Transaction;

struct Attachment;

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CREATORPUBKEY = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_SIGNATURES = 10,
    VT_HASH = 12,
    VT_ATTACHMENT = 14
  };
  const iroha::PublicKey *creatorPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_CREATORPUBKEY);
  }
  iroha::Command command_type() const {
    return static_cast<iroha::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const iroha::AddAsset *command_as_AddAsset() const {
    return (command_type() == iroha::Command::AddAsset)? static_cast<const iroha::AddAsset *>(command()) : nullptr;
  }
  const iroha::RemoveAsset *command_as_RemoveAsset() const {
    return (command_type() == iroha::Command::RemoveAsset)? static_cast<const iroha::RemoveAsset *>(command()) : nullptr;
  }
  const iroha::CreateAsset *command_as_CreateAsset() const {
    return (command_type() == iroha::Command::CreateAsset)? static_cast<const iroha::CreateAsset *>(command()) : nullptr;
  }
  const iroha::Transfer *command_as_Transfer() const {
    return (command_type() == iroha::Command::Transfer)? static_cast<const iroha::Transfer *>(command()) : nullptr;
  }
  const iroha::Add *command_as_Add() const {
    return (command_type() == iroha::Command::Add)? static_cast<const iroha::Add *>(command()) : nullptr;
  }
  const iroha::Remove *command_as_Remove() const {
    return (command_type() == iroha::Command::Remove)? static_cast<const iroha::Remove *>(command()) : nullptr;
  }
  const iroha::Execute *command_as_Execute() const {
    return (command_type() == iroha::Command::Execute)? static_cast<const iroha::Execute *>(command()) : nullptr;
  }
  const iroha::Store *command_as_Store() const {
    return (command_type() == iroha::Command::Store)? static_cast<const iroha::Store *>(command()) : nullptr;
  }
  const iroha::SetPeerTrust *command_as_SetPeerTrust() const {
    return (command_type() == iroha::Command::SetPeerTrust)? static_cast<const iroha::SetPeerTrust *>(command()) : nullptr;
  }
  const iroha::ChangePeerTrust *command_as_ChangePeerTrust() const {
    return (command_type() == iroha::Command::ChangePeerTrust)? static_cast<const iroha::ChangePeerTrust *>(command()) : nullptr;
  }
  const iroha::SetPeerActive *command_as_SetPeerActive() const {
    return (command_type() == iroha::Command::SetPeerActive)? static_cast<const iroha::SetPeerActive *>(command()) : nullptr;
  }
  const iroha::SetChaincode *command_as_SetChaincode() const {
    return (command_type() == iroha::Command::SetChaincode)? static_cast<const iroha::SetChaincode *>(command()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *signatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *>(VT_SIGNATURES);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const Attachment *attachment() const {
    return GetPointer<const Attachment *>(VT_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CREATORPUBKEY) &&
           verifier.VerifyTable(creatorPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATURES) &&
           verifier.Verify(signatures()) &&
           verifier.VerifyVectorOfTables(signatures()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTACHMENT) &&
           verifier.VerifyTable(attachment()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::AddAsset *Transaction::command_as<iroha::AddAsset>() const {
  return command_as_AddAsset();
}

template<> inline const iroha::RemoveAsset *Transaction::command_as<iroha::RemoveAsset>() const {
  return command_as_RemoveAsset();
}

template<> inline const iroha::CreateAsset *Transaction::command_as<iroha::CreateAsset>() const {
  return command_as_CreateAsset();
}

template<> inline const iroha::Transfer *Transaction::command_as<iroha::Transfer>() const {
  return command_as_Transfer();
}

template<> inline const iroha::Add *Transaction::command_as<iroha::Add>() const {
  return command_as_Add();
}

template<> inline const iroha::Remove *Transaction::command_as<iroha::Remove>() const {
  return command_as_Remove();
}

template<> inline const iroha::Execute *Transaction::command_as<iroha::Execute>() const {
  return command_as_Execute();
}

template<> inline const iroha::Store *Transaction::command_as<iroha::Store>() const {
  return command_as_Store();
}

template<> inline const iroha::SetPeerTrust *Transaction::command_as<iroha::SetPeerTrust>() const {
  return command_as_SetPeerTrust();
}

template<> inline const iroha::ChangePeerTrust *Transaction::command_as<iroha::ChangePeerTrust>() const {
  return command_as_ChangePeerTrust();
}

template<> inline const iroha::SetPeerActive *Transaction::command_as<iroha::SetPeerActive>() const {
  return command_as_SetPeerActive();
}

template<> inline const iroha::SetChaincode *Transaction::command_as<iroha::SetChaincode>() const {
  return command_as_SetChaincode();
}

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_creatorPubKey(flatbuffers::Offset<iroha::PublicKey> creatorPubKey) {
    fbb_.AddOffset(Transaction::VT_CREATORPUBKEY, creatorPubKey);
  }
  void add_command_type(iroha::Command command_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Transaction::VT_COMMAND, command);
  }
  void add_signatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>>> signatures) {
    fbb_.AddOffset(Transaction::VT_SIGNATURES, signatures);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(Transaction::VT_HASH, hash);
  }
  void add_attachment(flatbuffers::Offset<Attachment> attachment) {
    fbb_.AddOffset(Transaction::VT_ATTACHMENT, attachment);
  }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Transaction>(end);
    fbb_.Required(o, Transaction::VT_CREATORPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> creatorPubKey = 0,
    iroha::Command command_type = iroha::Command::NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>>> signatures = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<Attachment> attachment = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_attachment(attachment);
  builder_.add_hash(hash);
  builder_.add_signatures(signatures);
  builder_.add_command(command);
  builder_.add_creatorPubKey(creatorPubKey);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> creatorPubKey = 0,
    iroha::Command command_type = iroha::Command::NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<iroha::Signature>> *signatures = nullptr,
    const std::vector<uint8_t> *hash = nullptr,
    flatbuffers::Offset<Attachment> attachment = 0) {
  return iroha::CreateTransaction(
      _fbb,
      creatorPubKey,
      command_type,
      command,
      signatures ? _fbb.CreateVector<flatbuffers::Offset<iroha::Signature>>(*signatures) : 0,
      hash ? _fbb.CreateVector<uint8_t>(*hash) : 0,
      attachment);
}

struct Attachment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *mime() const {
    return GetPointer<const flatbuffers::String *>(VT_MIME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MIME) &&
           verifier.Verify(mime()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct AttachmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mime(flatbuffers::Offset<flatbuffers::String> mime) {
    fbb_.AddOffset(Attachment::VT_MIME, mime);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Attachment::VT_DATA, data);
  }
  AttachmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentBuilder &operator=(const AttachmentBuilder &);
  flatbuffers::Offset<Attachment> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Attachment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attachment> CreateAttachment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mime = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AttachmentBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_mime(mime);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attachment> CreateAttachmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  return iroha::CreateAttachment(
      _fbb,
      mime ? _fbb.CreateString(mime) : 0,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_

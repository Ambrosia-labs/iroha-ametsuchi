// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ASSET_IROHA_API_H_
#define FLATBUFFERS_GENERATED_ASSET_IROHA_API_H_

#include "flatbuffers/flatbuffers.h"

#include "key_generated.h"
#include "primitives_generated.h"

namespace iroha {
namespace api {

struct Asset;

struct AssetLogic;

struct Currency;

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10,
    VT_PROP = 12,
    VT_LOGIC = 14
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  bool KeyCompareLessThan(const Asset *o) const {
    return *asset_name() < *o->asset_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(asset_name()->c_str(), val);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::api::KeyValueObject>> *prop() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::api::KeyValueObject>> *>(VT_PROP);
  }
  const AssetLogic *logic() const {
    return GetPointer<const AssetLogic *>(VT_LOGIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROP) &&
           verifier.Verify(prop()) &&
           verifier.VerifyVectorOfTables(prop()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LOGIC) &&
           verifier.VerifyTable(logic()) &&
           verifier.EndTable();
  }
};

struct AssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(Asset::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Asset::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Asset::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Asset::VT_DESCRIPTION, description);
  }
  void add_prop(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::api::KeyValueObject>>> prop) {
    fbb_.AddOffset(Asset::VT_PROP, prop);
  }
  void add_logic(flatbuffers::Offset<AssetLogic> logic) {
    fbb_.AddOffset(Asset::VT_LOGIC, logic);
  }
  AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetBuilder &operator=(const AssetBuilder &);
  flatbuffers::Offset<Asset> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Asset>(end);
    fbb_.Required(o, Asset::VT_ASSET_NAME);
    fbb_.Required(o, Asset::VT_DOMAIN_NAME);
    fbb_.Required(o, Asset::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::api::KeyValueObject>>> prop = 0,
    flatbuffers::Offset<AssetLogic> logic = 0) {
  AssetBuilder builder_(_fbb);
  builder_.add_logic(logic);
  builder_.add_prop(prop);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Asset> CreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<iroha::api::KeyValueObject>> *prop = nullptr,
    flatbuffers::Offset<AssetLogic> logic = 0) {
  return iroha::api::CreateAsset(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0,
      prop ? _fbb.CreateVector<flatbuffers::Offset<iroha::api::KeyValueObject>>(*prop) : 0,
      logic);
}

struct AssetLogic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADD = 4,
    VT_REMOVE = 6,
    VT_TRANSFER = 8
  };
  const iroha::api::Chaincode *add() const {
    return GetPointer<const iroha::api::Chaincode *>(VT_ADD);
  }
  const iroha::api::Chaincode *remove() const {
    return GetPointer<const iroha::api::Chaincode *>(VT_REMOVE);
  }
  const iroha::api::Chaincode *transfer() const {
    return GetPointer<const iroha::api::Chaincode *>(VT_TRANSFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADD) &&
           verifier.VerifyTable(add()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REMOVE) &&
           verifier.VerifyTable(remove()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSFER) &&
           verifier.VerifyTable(transfer()) &&
           verifier.EndTable();
  }
};

struct AssetLogicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_add(flatbuffers::Offset<iroha::api::Chaincode> add) {
    fbb_.AddOffset(AssetLogic::VT_ADD, add);
  }
  void add_remove(flatbuffers::Offset<iroha::api::Chaincode> remove) {
    fbb_.AddOffset(AssetLogic::VT_REMOVE, remove);
  }
  void add_transfer(flatbuffers::Offset<iroha::api::Chaincode> transfer) {
    fbb_.AddOffset(AssetLogic::VT_TRANSFER, transfer);
  }
  AssetLogicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetLogicBuilder &operator=(const AssetLogicBuilder &);
  flatbuffers::Offset<AssetLogic> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<AssetLogic>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetLogic> CreateAssetLogic(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::api::Chaincode> add = 0,
    flatbuffers::Offset<iroha::api::Chaincode> remove = 0,
    flatbuffers::Offset<iroha::api::Chaincode> transfer = 0) {
  AssetLogicBuilder builder_(_fbb);
  builder_.add_transfer(transfer);
  builder_.add_remove(remove);
  builder_.add_add(add);
  return builder_.Finish();
}

struct Currency FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENCY_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10,
    VT_AMOUNT = 12,
    VT_PRECISION = 14
  };
  const flatbuffers::String *currency_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENCY_NAME);
  }
  bool KeyCompareLessThan(const Currency *o) const {
    return *currency_name() < *o->currency_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(currency_name()->c_str(), val);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  uint64_t amount() const {
    return GetField<uint64_t>(VT_AMOUNT, 0);
  }
  uint64_t precision() const {
    return GetField<uint64_t>(VT_PRECISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CURRENCY_NAME) &&
           verifier.Verify(currency_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           VerifyField<uint64_t>(verifier, VT_AMOUNT) &&
           VerifyField<uint64_t>(verifier, VT_PRECISION) &&
           verifier.EndTable();
  }
};

struct CurrencyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency_name(flatbuffers::Offset<flatbuffers::String> currency_name) {
    fbb_.AddOffset(Currency::VT_CURRENCY_NAME, currency_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Currency::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Currency::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Currency::VT_DESCRIPTION, description);
  }
  void add_amount(uint64_t amount) {
    fbb_.AddElement<uint64_t>(Currency::VT_AMOUNT, amount, 0);
  }
  void add_precision(uint64_t precision) {
    fbb_.AddElement<uint64_t>(Currency::VT_PRECISION, precision, 0);
  }
  CurrencyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurrencyBuilder &operator=(const CurrencyBuilder &);
  flatbuffers::Offset<Currency> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Currency>(end);
    fbb_.Required(o, Currency::VT_CURRENCY_NAME);
    fbb_.Required(o, Currency::VT_DOMAIN_NAME);
    fbb_.Required(o, Currency::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Currency> CreateCurrency(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> currency_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    uint64_t amount = 0,
    uint64_t precision = 0) {
  CurrencyBuilder builder_(_fbb);
  builder_.add_precision(precision);
  builder_.add_amount(amount);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_currency_name(currency_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Currency> CreateCurrencyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *currency_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr,
    uint64_t amount = 0,
    uint64_t precision = 0) {
  return iroha::api::CreateCurrency(
      _fbb,
      currency_name ? _fbb.CreateString(currency_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0,
      amount,
      precision);
}

}  // namespace api
}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_ASSET_IROHA_API_H_

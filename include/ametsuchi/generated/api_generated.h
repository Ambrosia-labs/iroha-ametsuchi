// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_API_IROHA_API_H_
#define FLATBUFFERS_GENERATED_API_IROHA_API_H_

#include "flatbuffers/flatbuffers.h"

namespace iroha {
namespace api {

struct Account;

struct Message;

struct Asset;

struct AssetLogic;

struct Currency;

struct Add;

struct Remove;

struct Store;

struct Transfer;

struct AddAsset;

struct RemoveAsset;

struct CreateAsset;

struct Execute;

struct SetChaincode;

struct SetPeerTrust;

struct ChangePeerTrust;

struct SetPeerActive;

struct AddSignatory;

struct SetAccountsUseKeys;

struct PublicKey;

struct ConsensusEvent;

struct TransactionResponse;

struct RecieverConfirmation;

struct Response;

struct Chaincode;

struct KeyValueObject;

struct UserPermissionRoot;

struct UserPermissionLedger;

struct UserPermissionDomain;

struct UserPermissionAsset;

struct Peer;

struct Signature;

struct Transaction;

struct Attachment;

enum class Object : uint8_t {
  NONE = 0,
  Peer = 1,
  Account = 2,
  Chaincode = 3,
  MIN = NONE,
  MAX = Chaincode
};

inline const char **EnumNamesObject() {
  static const char *names[] = {
    "NONE",
    "Peer",
    "Account",
    "Chaincode",
    nullptr
  };
  return names;
}

inline const char *EnumNameObject(Object e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObject()[index];
}

template<typename T> struct ObjectTraits {
  static const Object enum_value = Object::NONE;
};

template<> struct ObjectTraits<Peer> {
  static const Object enum_value = Object::Peer;
};

template<> struct ObjectTraits<Account> {
  static const Object enum_value = Object::Account;
};

template<> struct ObjectTraits<Chaincode> {
  static const Object enum_value = Object::Chaincode;
};

bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type);
bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AnyAsset : uint8_t {
  NONE = 0,
  Asset = 1,
  Currency = 2,
  MIN = NONE,
  MAX = Currency
};

inline const char **EnumNamesAnyAsset() {
  static const char *names[] = {
    "NONE",
    "Asset",
    "Currency",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyAsset(AnyAsset e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnyAsset()[index];
}

template<typename T> struct AnyAssetTraits {
  static const AnyAsset enum_value = AnyAsset::NONE;
};

template<> struct AnyAssetTraits<Asset> {
  static const AnyAsset enum_value = AnyAsset::Asset;
};

template<> struct AnyAssetTraits<Currency> {
  static const AnyAsset enum_value = AnyAsset::Currency;
};

bool VerifyAnyAsset(flatbuffers::Verifier &verifier, const void *obj, AnyAsset type);
bool VerifyAnyAssetVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

//////////////////////////////////////////
enum class Command : uint8_t {
  NONE = 0,
  AddAsset = 1,
  RemoveAsset = 2,
  CreateAsset = 3,
  Transfer = 4,
  Add = 5,
  Remove = 6,
  Execute = 7,
  Store = 8,
  SetPeerTrust = 9,
  ChangePeerTrust = 10,
  SetPeerActive = 11,
  SetChaincode = 12,
  MIN = NONE,
  MAX = SetChaincode
};

inline const char **EnumNamesCommand() {
  static const char *names[] = {
    "NONE",
    "AddAsset",
    "RemoveAsset",
    "CreateAsset",
    "Transfer",
    "Add",
    "Remove",
    "Execute",
    "Store",
    "SetPeerTrust",
    "ChangePeerTrust",
    "SetPeerActive",
    "SetChaincode",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command::NONE;
};

template<> struct CommandTraits<AddAsset> {
  static const Command enum_value = Command::AddAsset;
};

template<> struct CommandTraits<RemoveAsset> {
  static const Command enum_value = Command::RemoveAsset;
};

template<> struct CommandTraits<CreateAsset> {
  static const Command enum_value = Command::CreateAsset;
};

template<> struct CommandTraits<Transfer> {
  static const Command enum_value = Command::Transfer;
};

template<> struct CommandTraits<Add> {
  static const Command enum_value = Command::Add;
};

template<> struct CommandTraits<Remove> {
  static const Command enum_value = Command::Remove;
};

template<> struct CommandTraits<Execute> {
  static const Command enum_value = Command::Execute;
};

template<> struct CommandTraits<Store> {
  static const Command enum_value = Command::Store;
};

template<> struct CommandTraits<SetPeerTrust> {
  static const Command enum_value = Command::SetPeerTrust;
};

template<> struct CommandTraits<ChangePeerTrust> {
  static const Command enum_value = Command::ChangePeerTrust;
};

template<> struct CommandTraits<SetPeerActive> {
  static const Command enum_value = Command::SetPeerActive;
};

template<> struct CommandTraits<SetChaincode> {
  static const Command enum_value = Command::SetChaincode;
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class KeyAlgorithm : int8_t {
  ed25519 = 0,
  MIN = ed25519,
  MAX = ed25519
};

inline const char **EnumNamesKeyAlgorithm() {
  static const char *names[] = {
    "ed25519",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyAlgorithm(KeyAlgorithm e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKeyAlgorithm()[index];
}

enum class Code : uint8_t {
  COMMIT = 0,
  FAIL = 1,
  MIN = COMMIT,
  MAX = FAIL
};

inline const char **EnumNamesCode() {
  static const char *names[] = {
    "COMMIT",
    "FAIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCode(Code e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCode()[index];
}

/////////////////////////////////////
enum class ProgrammingLanguage : uint8_t {
  Java8 = 0,
  MIN = Java8,
  MAX = Java8
};

inline const char **EnumNamesProgrammingLanguage() {
  static const char *names[] = {
    "Java8",
    nullptr
  };
  return names;
}

inline const char *EnumNameProgrammingLanguage(ProgrammingLanguage e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesProgrammingLanguage()[index];
}

enum class UserPermission : uint8_t {
  NONE = 0,
  UserPermissionRoot = 1,
  UserPermissionLedger = 2,
  UserPermissionDomain = 3,
  UserPermissionAsset = 4,
  MIN = NONE,
  MAX = UserPermissionAsset
};

inline const char **EnumNamesUserPermission() {
  static const char *names[] = {
    "NONE",
    "UserPermissionRoot",
    "UserPermissionLedger",
    "UserPermissionDomain",
    "UserPermissionAsset",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserPermission(UserPermission e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesUserPermission()[index];
}

template<typename T> struct UserPermissionTraits {
  static const UserPermission enum_value = UserPermission::NONE;
};

template<> struct UserPermissionTraits<UserPermissionRoot> {
  static const UserPermission enum_value = UserPermission::UserPermissionRoot;
};

template<> struct UserPermissionTraits<UserPermissionLedger> {
  static const UserPermission enum_value = UserPermission::UserPermissionLedger;
};

template<> struct UserPermissionTraits<UserPermissionDomain> {
  static const UserPermission enum_value = UserPermission::UserPermissionDomain;
};

template<> struct UserPermissionTraits<UserPermissionAsset> {
  static const UserPermission enum_value = UserPermission::UserPermissionAsset;
};

bool VerifyUserPermission(flatbuffers::Verifier &verifier, const void *obj, UserPermission type);
bool VerifyUserPermissionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Account FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBKEY = 4,
    VT_ALIAS = 6,
    VT_SIGNATORIES = 8,
    VT_USEKEYS = 10
  };
  const PublicKey *pubKey() const {
    return GetPointer<const PublicKey *>(VT_PUBKEY);
  }
  const flatbuffers::String *alias() const {
    return GetPointer<const flatbuffers::String *>(VT_ALIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PublicKey>> *signatories() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PublicKey>> *>(VT_SIGNATORIES);
  }
  uint16_t useKeys() const {
    return GetField<uint16_t>(VT_USEKEYS, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBKEY) &&
           verifier.VerifyTable(pubKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATORIES) &&
           verifier.Verify(signatories()) &&
           verifier.VerifyVectorOfTables(signatories()) &&
           VerifyField<uint16_t>(verifier, VT_USEKEYS) &&
           verifier.EndTable();
  }
};

struct AccountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubKey(flatbuffers::Offset<PublicKey> pubKey) {
    fbb_.AddOffset(Account::VT_PUBKEY, pubKey);
  }
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) {
    fbb_.AddOffset(Account::VT_ALIAS, alias);
  }
  void add_signatories(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PublicKey>>> signatories) {
    fbb_.AddOffset(Account::VT_SIGNATORIES, signatories);
  }
  void add_useKeys(uint16_t useKeys) {
    fbb_.AddElement<uint16_t>(Account::VT_USEKEYS, useKeys, 1);
  }
  AccountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountBuilder &operator=(const AccountBuilder &);
  flatbuffers::Offset<Account> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Account>(end);
    fbb_.Required(o, Account::VT_PUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<Account> CreateAccount(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> pubKey = 0,
    flatbuffers::Offset<flatbuffers::String> alias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PublicKey>>> signatories = 0,
    uint16_t useKeys = 1) {
  AccountBuilder builder_(_fbb);
  builder_.add_signatories(signatories);
  builder_.add_alias(alias);
  builder_.add_pubKey(pubKey);
  builder_.add_useKeys(useKeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<Account> CreateAccountDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> pubKey = 0,
    const char *alias = nullptr,
    const std::vector<flatbuffers::Offset<PublicKey>> *signatories = nullptr,
    uint16_t useKeys = 1) {
  return iroha::api::CreateAccount(
      _fbb,
      pubKey,
      alias ? _fbb.CreateString(alias) : 0,
      signatories ? _fbb.CreateVector<flatbuffers::Offset<PublicKey>>(*signatories) : 0,
      useKeys);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_DATA = 6
  };
  const PublicKey *accPubKey() const {
    return GetPointer<const PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<PublicKey> accPubKey) {
    fbb_.AddOffset(Message::VT_ACCPUBKEY, accPubKey);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>>> data) {
    fbb_.AddOffset(Message::VT_DATA, data);
  }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Message>(end);
    fbb_.Required(o, Message::VT_ACCPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>>> data = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<KeyValueObject>> *data = nullptr) {
  return iroha::api::CreateMessage(
      _fbb,
      accPubKey,
      data ? _fbb.CreateVector<flatbuffers::Offset<KeyValueObject>>(*data) : 0);
}

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10,
    VT_PROP = 12,
    VT_LOGIC = 14
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  bool KeyCompareLessThan(const Asset *o) const {
    return *asset_name() < *o->asset_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(asset_name()->c_str(), val);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>> *prop() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>> *>(VT_PROP);
  }
  const AssetLogic *logic() const {
    return GetPointer<const AssetLogic *>(VT_LOGIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROP) &&
           verifier.Verify(prop()) &&
           verifier.VerifyVectorOfTables(prop()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LOGIC) &&
           verifier.VerifyTable(logic()) &&
           verifier.EndTable();
  }
};

struct AssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(Asset::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Asset::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Asset::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Asset::VT_DESCRIPTION, description);
  }
  void add_prop(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>>> prop) {
    fbb_.AddOffset(Asset::VT_PROP, prop);
  }
  void add_logic(flatbuffers::Offset<AssetLogic> logic) {
    fbb_.AddOffset(Asset::VT_LOGIC, logic);
  }
  AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetBuilder &operator=(const AssetBuilder &);
  flatbuffers::Offset<Asset> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Asset>(end);
    fbb_.Required(o, Asset::VT_ASSET_NAME);
    fbb_.Required(o, Asset::VT_DOMAIN_NAME);
    fbb_.Required(o, Asset::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>>> prop = 0,
    flatbuffers::Offset<AssetLogic> logic = 0) {
  AssetBuilder builder_(_fbb);
  builder_.add_logic(logic);
  builder_.add_prop(prop);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Asset> CreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<KeyValueObject>> *prop = nullptr,
    flatbuffers::Offset<AssetLogic> logic = 0) {
  return iroha::api::CreateAsset(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0,
      prop ? _fbb.CreateVector<flatbuffers::Offset<KeyValueObject>>(*prop) : 0,
      logic);
}

struct AssetLogic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADD = 4,
    VT_REMOVE = 6,
    VT_TRANSFER = 8
  };
  const Chaincode *add() const {
    return GetPointer<const Chaincode *>(VT_ADD);
  }
  const Chaincode *remove() const {
    return GetPointer<const Chaincode *>(VT_REMOVE);
  }
  const Chaincode *transfer() const {
    return GetPointer<const Chaincode *>(VT_TRANSFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADD) &&
           verifier.VerifyTable(add()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REMOVE) &&
           verifier.VerifyTable(remove()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSFER) &&
           verifier.VerifyTable(transfer()) &&
           verifier.EndTable();
  }
};

struct AssetLogicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_add(flatbuffers::Offset<Chaincode> add) {
    fbb_.AddOffset(AssetLogic::VT_ADD, add);
  }
  void add_remove(flatbuffers::Offset<Chaincode> remove) {
    fbb_.AddOffset(AssetLogic::VT_REMOVE, remove);
  }
  void add_transfer(flatbuffers::Offset<Chaincode> transfer) {
    fbb_.AddOffset(AssetLogic::VT_TRANSFER, transfer);
  }
  AssetLogicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetLogicBuilder &operator=(const AssetLogicBuilder &);
  flatbuffers::Offset<AssetLogic> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<AssetLogic>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetLogic> CreateAssetLogic(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Chaincode> add = 0,
    flatbuffers::Offset<Chaincode> remove = 0,
    flatbuffers::Offset<Chaincode> transfer = 0) {
  AssetLogicBuilder builder_(_fbb);
  builder_.add_transfer(transfer);
  builder_.add_remove(remove);
  builder_.add_add(add);
  return builder_.Finish();
}

struct Currency FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENCY_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10,
    VT_AMOUNT = 12,
    VT_PRECISION = 14
  };
  const flatbuffers::String *currency_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENCY_NAME);
  }
  bool KeyCompareLessThan(const Currency *o) const {
    return *currency_name() < *o->currency_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(currency_name()->c_str(), val);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  uint64_t amount() const {
    return GetField<uint64_t>(VT_AMOUNT, 0);
  }
  uint64_t precision() const {
    return GetField<uint64_t>(VT_PRECISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CURRENCY_NAME) &&
           verifier.Verify(currency_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           VerifyField<uint64_t>(verifier, VT_AMOUNT) &&
           VerifyField<uint64_t>(verifier, VT_PRECISION) &&
           verifier.EndTable();
  }
};

struct CurrencyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency_name(flatbuffers::Offset<flatbuffers::String> currency_name) {
    fbb_.AddOffset(Currency::VT_CURRENCY_NAME, currency_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Currency::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Currency::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Currency::VT_DESCRIPTION, description);
  }
  void add_amount(uint64_t amount) {
    fbb_.AddElement<uint64_t>(Currency::VT_AMOUNT, amount, 0);
  }
  void add_precision(uint64_t precision) {
    fbb_.AddElement<uint64_t>(Currency::VT_PRECISION, precision, 0);
  }
  CurrencyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurrencyBuilder &operator=(const CurrencyBuilder &);
  flatbuffers::Offset<Currency> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Currency>(end);
    fbb_.Required(o, Currency::VT_CURRENCY_NAME);
    fbb_.Required(o, Currency::VT_DOMAIN_NAME);
    fbb_.Required(o, Currency::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Currency> CreateCurrency(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> currency_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    uint64_t amount = 0,
    uint64_t precision = 0) {
  CurrencyBuilder builder_(_fbb);
  builder_.add_precision(precision);
  builder_.add_amount(amount);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_currency_name(currency_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Currency> CreateCurrencyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *currency_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr,
    uint64_t amount = 0,
    uint64_t precision = 0) {
  return iroha::api::CreateCurrency(
      _fbb,
      currency_name ? _fbb.CreateString(currency_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0,
      amount,
      precision);
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const Peer *object_as_Peer() const {
    return (object_type() == Object::Peer)? static_cast<const Peer *>(object()) : nullptr;
  }
  const Account *object_as_Account() const {
    return (object_type() == Object::Account)? static_cast<const Account *>(object()) : nullptr;
  }
  const Chaincode *object_as_Chaincode() const {
    return (object_type() == Object::Chaincode)? static_cast<const Chaincode *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Peer *Add::object_as<Peer>() const {
  return object_as_Peer();
}

template<> inline const Account *Add::object_as<Account>() const {
  return object_as_Account();
}

template<> inline const Chaincode *Add::object_as<Chaincode>() const {
  return object_as_Chaincode();
}

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Add::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Add::VT_OBJECT, object);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Add>(end);
    fbb_.Required(o, Add::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Remove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const Peer *object_as_Peer() const {
    return (object_type() == Object::Peer)? static_cast<const Peer *>(object()) : nullptr;
  }
  const Account *object_as_Account() const {
    return (object_type() == Object::Account)? static_cast<const Account *>(object()) : nullptr;
  }
  const Chaincode *object_as_Chaincode() const {
    return (object_type() == Object::Chaincode)? static_cast<const Chaincode *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Peer *Remove::object_as<Peer>() const {
  return object_as_Peer();
}

template<> inline const Account *Remove::object_as<Account>() const {
  return object_as_Account();
}

template<> inline const Chaincode *Remove::object_as<Chaincode>() const {
  return object_as_Chaincode();
}

struct RemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Remove::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Remove::VT_OBJECT, object);
  }
  RemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveBuilder &operator=(const RemoveBuilder &);
  flatbuffers::Offset<Remove> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Remove>(end);
    fbb_.Required(o, Remove::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Remove> CreateRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  RemoveBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Store FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_DATA = 6
  };
  const PublicKey *accPubKey() const {
    return GetPointer<const PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct StoreBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<PublicKey> accPubKey) {
    fbb_.AddOffset(Store::VT_ACCPUBKEY, accPubKey);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>>> data) {
    fbb_.AddOffset(Store::VT_DATA, data);
  }
  StoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StoreBuilder &operator=(const StoreBuilder &);
  flatbuffers::Offset<Store> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Store>(end);
    fbb_.Required(o, Store::VT_ACCPUBKEY);
    fbb_.Required(o, Store::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<Store> CreateStore(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValueObject>>> data = 0) {
  StoreBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Store> CreateStoreDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<KeyValueObject>> *data = nullptr) {
  return iroha::api::CreateStore(
      _fbb,
      accPubKey,
      data ? _fbb.CreateVector<flatbuffers::Offset<KeyValueObject>>(*data) : 0);
}

struct Transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENCY = 4,
    VT_SENDER = 6,
    VT_RECEIVER = 8
  };
  const Asset *currency() const {
    return GetPointer<const Asset *>(VT_CURRENCY);
  }
  const PublicKey *sender() const {
    return GetPointer<const PublicKey *>(VT_SENDER);
  }
  const PublicKey *receiver() const {
    return GetPointer<const PublicKey *>(VT_RECEIVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CURRENCY) &&
           verifier.VerifyTable(currency()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.VerifyTable(sender()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.VerifyTable(receiver()) &&
           verifier.EndTable();
  }
};

struct TransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency(flatbuffers::Offset<Asset> currency) {
    fbb_.AddOffset(Transfer::VT_CURRENCY, currency);
  }
  void add_sender(flatbuffers::Offset<PublicKey> sender) {
    fbb_.AddOffset(Transfer::VT_SENDER, sender);
  }
  void add_receiver(flatbuffers::Offset<PublicKey> receiver) {
    fbb_.AddOffset(Transfer::VT_RECEIVER, receiver);
  }
  TransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransferBuilder &operator=(const TransferBuilder &);
  flatbuffers::Offset<Transfer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Transfer>(end);
    fbb_.Required(o, Transfer::VT_CURRENCY);
    fbb_.Required(o, Transfer::VT_SENDER);
    fbb_.Required(o, Transfer::VT_RECEIVER);
    return o;
  }
};

inline flatbuffers::Offset<Transfer> CreateTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Asset> currency = 0,
    flatbuffers::Offset<PublicKey> sender = 0,
    flatbuffers::Offset<PublicKey> receiver = 0) {
  TransferBuilder builder_(_fbb);
  builder_.add_receiver(receiver);
  builder_.add_sender(sender);
  builder_.add_currency(currency);
  return builder_.Finish();
}

//////////////////////////////////////////
/// Commands for Asset
struct AddAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET = 6
  };
  const PublicKey *accPubKey() const {
    return GetPointer<const PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Asset>> *asset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Asset>> *>(VT_ASSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           verifier.VerifyVectorOfTables(asset()) &&
           verifier.EndTable();
  }
};

struct AddAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<PublicKey> accPubKey) {
    fbb_.AddOffset(AddAsset::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> asset) {
    fbb_.AddOffset(AddAsset::VT_ASSET, asset);
  }
  AddAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddAssetBuilder &operator=(const AddAssetBuilder &);
  flatbuffers::Offset<AddAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AddAsset>(end);
    fbb_.Required(o, AddAsset::VT_ACCPUBKEY);
    fbb_.Required(o, AddAsset::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<AddAsset> CreateAddAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> asset = 0) {
  AddAssetBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddAsset> CreateAddAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<Asset>> *asset = nullptr) {
  return iroha::api::CreateAddAsset(
      _fbb,
      accPubKey,
      asset ? _fbb.CreateVector<flatbuffers::Offset<Asset>>(*asset) : 0);
}

struct RemoveAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET = 6
  };
  const PublicKey *accPubKey() const {
    return GetPointer<const PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Asset>> *asset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Asset>> *>(VT_ASSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           verifier.VerifyVectorOfTables(asset()) &&
           verifier.EndTable();
  }
};

struct RemoveAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<PublicKey> accPubKey) {
    fbb_.AddOffset(RemoveAsset::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> asset) {
    fbb_.AddOffset(RemoveAsset::VT_ASSET, asset);
  }
  RemoveAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveAssetBuilder &operator=(const RemoveAssetBuilder &);
  flatbuffers::Offset<RemoveAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RemoveAsset>(end);
    fbb_.Required(o, RemoveAsset::VT_ACCPUBKEY);
    fbb_.Required(o, RemoveAsset::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<RemoveAsset> CreateRemoveAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> asset = 0) {
  RemoveAssetBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveAsset> CreateRemoveAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<Asset>> *asset = nullptr) {
  return iroha::api::CreateRemoveAsset(
      _fbb,
      accPubKey,
      asset ? _fbb.CreateVector<flatbuffers::Offset<Asset>>(*asset) : 0);
}

struct CreateAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           verifier.EndTable();
  }
};

struct CreateAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(CreateAsset::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(CreateAsset::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(CreateAsset::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(CreateAsset::VT_DESCRIPTION, description);
  }
  CreateAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateAssetBuilder &operator=(const CreateAssetBuilder &);
  flatbuffers::Offset<CreateAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CreateAsset>(end);
    fbb_.Required(o, CreateAsset::VT_ASSET_NAME);
    fbb_.Required(o, CreateAsset::VT_DOMAIN_NAME);
    fbb_.Required(o, CreateAsset::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<CreateAsset> CreateCreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0) {
  CreateAssetBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateAsset> CreateCreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr) {
  return iroha::api::CreateCreateAsset(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0);
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Chaincode
struct Execute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8
  };
  const flatbuffers::String *code_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE_NAME) &&
           verifier.Verify(code_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           verifier.EndTable();
  }
};

struct ExecuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code_name(flatbuffers::Offset<flatbuffers::String> code_name) {
    fbb_.AddOffset(Execute::VT_CODE_NAME, code_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Execute::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Execute::VT_LEDGER_NAME, ledger_name);
  }
  ExecuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecuteBuilder &operator=(const ExecuteBuilder &);
  flatbuffers::Offset<Execute> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Execute>(end);
    fbb_.Required(o, Execute::VT_CODE_NAME);
    fbb_.Required(o, Execute::VT_DOMAIN_NAME);
    fbb_.Required(o, Execute::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Execute> CreateExecute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0) {
  ExecuteBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_code_name(code_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Execute> CreateExecuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr) {
  return iroha::api::CreateExecute(
      _fbb,
      code_name ? _fbb.CreateString(code_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0);
}

struct SetChaincode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAINCODE = 4
  };
  const Chaincode *chaincode() const {
    return GetPointer<const Chaincode *>(VT_CHAINCODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CHAINCODE) &&
           verifier.VerifyTable(chaincode()) &&
           verifier.EndTable();
  }
};

struct SetChaincodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chaincode(flatbuffers::Offset<Chaincode> chaincode) {
    fbb_.AddOffset(SetChaincode::VT_CHAINCODE, chaincode);
  }
  SetChaincodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetChaincodeBuilder &operator=(const SetChaincodeBuilder &);
  flatbuffers::Offset<SetChaincode> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SetChaincode>(end);
    fbb_.Required(o, SetChaincode::VT_CHAINCODE);
    return o;
  }
};

inline flatbuffers::Offset<SetChaincode> CreateSetChaincode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Chaincode> chaincode = 0) {
  SetChaincodeBuilder builder_(_fbb);
  builder_.add_chaincode(chaincode);
  return builder_.Finish();
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Peer
struct SetPeerTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_TRUST = 6
  };
  const PublicKey *peerPubKey() const {
    return GetPointer<const PublicKey *>(VT_PEERPUBKEY);
  }
  double trust() const {
    return GetField<double>(VT_TRUST, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<double>(verifier, VT_TRUST) &&
           verifier.EndTable();
  }
};

struct SetPeerTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<PublicKey> peerPubKey) {
    fbb_.AddOffset(SetPeerTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_trust(double trust) {
    fbb_.AddElement<double>(SetPeerTrust::VT_TRUST, trust, 0.0);
  }
  SetPeerTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPeerTrustBuilder &operator=(const SetPeerTrustBuilder &);
  flatbuffers::Offset<SetPeerTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SetPeerTrust>(end);
    fbb_.Required(o, SetPeerTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<SetPeerTrust> CreateSetPeerTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> peerPubKey = 0,
    double trust = 0.0) {
  SetPeerTrustBuilder builder_(_fbb);
  builder_.add_trust(trust);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

struct ChangePeerTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_DELTA = 6
  };
  const PublicKey *peerPubKey() const {
    return GetPointer<const PublicKey *>(VT_PEERPUBKEY);
  }
  double delta() const {
    return GetField<double>(VT_DELTA, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<double>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct ChangePeerTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<PublicKey> peerPubKey) {
    fbb_.AddOffset(ChangePeerTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_delta(double delta) {
    fbb_.AddElement<double>(ChangePeerTrust::VT_DELTA, delta, 0.0);
  }
  ChangePeerTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChangePeerTrustBuilder &operator=(const ChangePeerTrustBuilder &);
  flatbuffers::Offset<ChangePeerTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ChangePeerTrust>(end);
    fbb_.Required(o, ChangePeerTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<ChangePeerTrust> CreateChangePeerTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> peerPubKey = 0,
    double delta = 0.0) {
  ChangePeerTrustBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

struct SetPeerActive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_ACTIVE = 6
  };
  const PublicKey *peerPubKey() const {
    return GetPointer<const PublicKey *>(VT_PEERPUBKEY);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           verifier.EndTable();
  }
};

struct SetPeerActiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<PublicKey> peerPubKey) {
    fbb_.AddOffset(SetPeerActive::VT_PEERPUBKEY, peerPubKey);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(SetPeerActive::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  SetPeerActiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPeerActiveBuilder &operator=(const SetPeerActiveBuilder &);
  flatbuffers::Offset<SetPeerActive> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SetPeerActive>(end);
    fbb_.Required(o, SetPeerActive::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<SetPeerActive> CreateSetPeerActive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> peerPubKey = 0,
    bool active = false) {
  SetPeerActiveBuilder builder_(_fbb);
  builder_.add_peerPubKey(peerPubKey);
  builder_.add_active(active);
  return builder_.Finish();
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Account
struct AddSignatory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4,
    VT_SIGNATORY = 6
  };
  const PublicKey *account() const {
    return GetPointer<const PublicKey *>(VT_ACCOUNT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PublicKey>> *signatory() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PublicKey>> *>(VT_SIGNATORY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.VerifyTable(account()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATORY) &&
           verifier.Verify(signatory()) &&
           verifier.VerifyVectorOfTables(signatory()) &&
           verifier.EndTable();
  }
};

struct AddSignatoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<PublicKey> account) {
    fbb_.AddOffset(AddSignatory::VT_ACCOUNT, account);
  }
  void add_signatory(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PublicKey>>> signatory) {
    fbb_.AddOffset(AddSignatory::VT_SIGNATORY, signatory);
  }
  AddSignatoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddSignatoryBuilder &operator=(const AddSignatoryBuilder &);
  flatbuffers::Offset<AddSignatory> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AddSignatory>(end);
    fbb_.Required(o, AddSignatory::VT_ACCOUNT);
    fbb_.Required(o, AddSignatory::VT_SIGNATORY);
    return o;
  }
};

inline flatbuffers::Offset<AddSignatory> CreateAddSignatory(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> account = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PublicKey>>> signatory = 0) {
  AddSignatoryBuilder builder_(_fbb);
  builder_.add_signatory(signatory);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddSignatory> CreateAddSignatoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> account = 0,
    const std::vector<flatbuffers::Offset<PublicKey>> *signatory = nullptr) {
  return iroha::api::CreateAddSignatory(
      _fbb,
      account,
      signatory ? _fbb.CreateVector<flatbuffers::Offset<PublicKey>>(*signatory) : 0);
}

struct SetAccountsUseKeys FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTS = 4,
    VT_USEKEYS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<PublicKey>> *accounts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PublicKey>> *>(VT_ACCOUNTS);
  }
  uint16_t useKeys() const {
    return GetField<uint16_t>(VT_USEKEYS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNTS) &&
           verifier.Verify(accounts()) &&
           verifier.VerifyVectorOfTables(accounts()) &&
           VerifyField<uint16_t>(verifier, VT_USEKEYS) &&
           verifier.EndTable();
  }
};

struct SetAccountsUseKeysBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PublicKey>>> accounts) {
    fbb_.AddOffset(SetAccountsUseKeys::VT_ACCOUNTS, accounts);
  }
  void add_useKeys(uint16_t useKeys) {
    fbb_.AddElement<uint16_t>(SetAccountsUseKeys::VT_USEKEYS, useKeys, 0);
  }
  SetAccountsUseKeysBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetAccountsUseKeysBuilder &operator=(const SetAccountsUseKeysBuilder &);
  flatbuffers::Offset<SetAccountsUseKeys> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SetAccountsUseKeys>(end);
    fbb_.Required(o, SetAccountsUseKeys::VT_ACCOUNTS);
    return o;
  }
};

inline flatbuffers::Offset<SetAccountsUseKeys> CreateSetAccountsUseKeys(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PublicKey>>> accounts = 0,
    uint16_t useKeys = 0) {
  SetAccountsUseKeysBuilder builder_(_fbb);
  builder_.add_accounts(accounts);
  builder_.add_useKeys(useKeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetAccountsUseKeys> CreateSetAccountsUseKeysDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PublicKey>> *accounts = nullptr,
    uint16_t useKeys = 0) {
  return iroha::api::CreateSetAccountsUseKeys(
      _fbb,
      accounts ? _fbb.CreateVector<flatbuffers::Offset<PublicKey>>(*accounts) : 0,
      useKeys);
}

struct PublicKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALGORITHM = 4,
    VT_DATA = 6
  };
  KeyAlgorithm algorithm() const {
    return static_cast<KeyAlgorithm>(GetField<int8_t>(VT_ALGORITHM, 0));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ALGORITHM) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct PublicKeyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algorithm(KeyAlgorithm algorithm) {
    fbb_.AddElement<int8_t>(PublicKey::VT_ALGORITHM, static_cast<int8_t>(algorithm), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(PublicKey::VT_DATA, data);
  }
  PublicKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PublicKeyBuilder &operator=(const PublicKeyBuilder &);
  flatbuffers::Offset<PublicKey> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<PublicKey>(end);
    fbb_.Required(o, PublicKey::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<PublicKey> CreatePublicKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    KeyAlgorithm algorithm = KeyAlgorithm::ed25519,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  PublicKeyBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_algorithm(algorithm);
  return builder_.Finish();
}

inline flatbuffers::Offset<PublicKey> CreatePublicKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KeyAlgorithm algorithm = KeyAlgorithm::ed25519,
    const std::vector<uint8_t> *data = nullptr) {
  return iroha::api::CreatePublicKey(
      _fbb,
      algorithm,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct ConsensusEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERSIGNATURES = 4,
    VT_TRANSACTIONS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Signature>> *peerSignatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Signature>> *>(VT_PEERSIGNATURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transactions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PEERSIGNATURES) &&
           verifier.Verify(peerSignatures()) &&
           verifier.VerifyVectorOfTables(peerSignatures()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSACTIONS) &&
           verifier.Verify(transactions()) &&
           verifier.VerifyVectorOfTables(transactions()) &&
           verifier.EndTable();
  }
};

struct ConsensusEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Signature>>> peerSignatures) {
    fbb_.AddOffset(ConsensusEvent::VT_PEERSIGNATURES, peerSignatures);
  }
  void add_transactions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transactions) {
    fbb_.AddOffset(ConsensusEvent::VT_TRANSACTIONS, transactions);
  }
  ConsensusEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConsensusEventBuilder &operator=(const ConsensusEventBuilder &);
  flatbuffers::Offset<ConsensusEvent> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ConsensusEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Signature>>> peerSignatures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transactions = 0) {
  ConsensusEventBuilder builder_(_fbb);
  builder_.add_transactions(transactions);
  builder_.add_peerSignatures(peerSignatures);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Signature>> *peerSignatures = nullptr,
    const std::vector<flatbuffers::Offset<Transaction>> *transactions = nullptr) {
  return iroha::api::CreateConsensusEvent(
      _fbb,
      peerSignatures ? _fbb.CreateVector<flatbuffers::Offset<Signature>>(*peerSignatures) : 0,
      transactions ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transactions) : 0);
}

struct TransactionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4,
    VT_CODE = 6,
    VT_TRANSACTION = 8
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  Code code() const {
    return static_cast<Code>(GetField<uint8_t>(VT_CODE, 0));
  }
  const Transaction *transaction() const {
    return GetPointer<const Transaction *>(VT_TRANSACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<uint8_t>(verifier, VT_CODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.VerifyTable(transaction()) &&
           verifier.EndTable();
  }
};

struct TransactionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(TransactionResponse::VT_MESSAGE, message);
  }
  void add_code(Code code) {
    fbb_.AddElement<uint8_t>(TransactionResponse::VT_CODE, static_cast<uint8_t>(code), 0);
  }
  void add_transaction(flatbuffers::Offset<Transaction> transaction) {
    fbb_.AddOffset(TransactionResponse::VT_TRANSACTION, transaction);
  }
  TransactionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionResponseBuilder &operator=(const TransactionResponseBuilder &);
  flatbuffers::Offset<TransactionResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<TransactionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransactionResponse> CreateTransactionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    Code code = Code::COMMIT,
    flatbuffers::Offset<Transaction> transaction = 0) {
  TransactionResponseBuilder builder_(_fbb);
  builder_.add_transaction(transaction);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransactionResponse> CreateTransactionResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    Code code = Code::COMMIT,
    flatbuffers::Offset<Transaction> transaction = 0) {
  return iroha::api::CreateTransactionResponse(
      _fbb,
      message ? _fbb.CreateString(message) : 0,
      code,
      transaction);
}

struct RecieverConfirmation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SIGNATURE = 4,
    VT_HASH = 6
  };
  const Signature *signature() const {
    return GetPointer<const Signature *>(VT_SIGNATURE);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.VerifyTable(signature()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           verifier.EndTable();
  }
};

struct RecieverConfirmationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_signature(flatbuffers::Offset<Signature> signature) {
    fbb_.AddOffset(RecieverConfirmation::VT_SIGNATURE, signature);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(RecieverConfirmation::VT_HASH, hash);
  }
  RecieverConfirmationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecieverConfirmationBuilder &operator=(const RecieverConfirmationBuilder &);
  flatbuffers::Offset<RecieverConfirmation> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RecieverConfirmation>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecieverConfirmation> CreateRecieverConfirmation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Signature> signature = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0) {
  RecieverConfirmationBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_signature(signature);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecieverConfirmation> CreateRecieverConfirmationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Signature> signature = 0,
    const std::vector<uint8_t> *hash = nullptr) {
  return iroha::api::CreateRecieverConfirmation(
      _fbb,
      signature,
      hash ? _fbb.CreateVector<uint8_t>(*hash) : 0);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_CODE = 8,
    VT_SIGNATURE = 10
  };
  const flatbuffers::Vector<uint8_t> *message_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MESSAGE_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *message() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_MESSAGE);
  }
  Code code() const {
    return static_cast<Code>(GetField<uint8_t>(VT_CODE, 0));
  }
  const Signature *signature() const {
    return GetPointer<const Signature *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE_TYPE) &&
           verifier.Verify(message_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyObjectVector(verifier, message(), message_type()) &&
           VerifyField<uint8_t>(verifier, VT_CODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.VerifyTable(signature()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message_type) {
    fbb_.AddOffset(Response::VT_MESSAGE_TYPE, message_type);
  }
  void add_message(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> message) {
    fbb_.AddOffset(Response::VT_MESSAGE, message);
  }
  void add_code(Code code) {
    fbb_.AddElement<uint8_t>(Response::VT_CODE, static_cast<uint8_t>(code), 0);
  }
  void add_signature(flatbuffers::Offset<Signature> signature) {
    fbb_.AddOffset(Response::VT_SIGNATURE, signature);
  }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> message = 0,
    Code code = Code::COMMIT,
    flatbuffers::Offset<Signature> signature = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *message_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *message = nullptr,
    Code code = Code::COMMIT,
    flatbuffers::Offset<Signature> signature = 0) {
  return iroha::api::CreateResponse(
      _fbb,
      message_type ? _fbb.CreateVector<uint8_t>(*message_type) : 0,
      message ? _fbb.CreateVector<flatbuffers::Offset<void>>(*message) : 0,
      code,
      signature);
}

struct Chaincode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_LANGUAGE = 10,
    VT_CODE = 12
  };
  const flatbuffers::String *code_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE_NAME);
  }
  bool KeyCompareLessThan(const Chaincode *o) const {
    return *code_name() < *o->code_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(code_name()->c_str(), val);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  ProgrammingLanguage language() const {
    return static_cast<ProgrammingLanguage>(GetField<uint8_t>(VT_LANGUAGE, 0));
  }
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE_NAME) &&
           verifier.Verify(code_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<uint8_t>(verifier, VT_LANGUAGE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           verifier.EndTable();
  }
};

struct ChaincodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code_name(flatbuffers::Offset<flatbuffers::String> code_name) {
    fbb_.AddOffset(Chaincode::VT_CODE_NAME, code_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(Chaincode::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(Chaincode::VT_LEDGER_NAME, ledger_name);
  }
  void add_language(ProgrammingLanguage language) {
    fbb_.AddElement<uint8_t>(Chaincode::VT_LANGUAGE, static_cast<uint8_t>(language), 0);
  }
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(Chaincode::VT_CODE, code);
  }
  ChaincodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChaincodeBuilder &operator=(const ChaincodeBuilder &);
  flatbuffers::Offset<Chaincode> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Chaincode>(end);
    fbb_.Required(o, Chaincode::VT_CODE_NAME);
    fbb_.Required(o, Chaincode::VT_DOMAIN_NAME);
    fbb_.Required(o, Chaincode::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Chaincode> CreateChaincode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    ProgrammingLanguage language = ProgrammingLanguage::Java8,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0) {
  ChaincodeBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_code_name(code_name);
  builder_.add_language(language);
  return builder_.Finish();
}

inline flatbuffers::Offset<Chaincode> CreateChaincodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    ProgrammingLanguage language = ProgrammingLanguage::Java8,
    const std::vector<uint8_t> *code = nullptr) {
  return iroha::api::CreateChaincode(
      _fbb,
      code_name ? _fbb.CreateString(code_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      language,
      code ? _fbb.CreateVector<uint8_t>(*code) : 0);
}

/////////////////////////////////////
/// Key-Value object
struct KeyValueObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const KeyValueObject *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValueObject::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(KeyValueObject::VT_VALUE, value);
  }
  KeyValueObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueObjectBuilder &operator=(const KeyValueObjectBuilder &);
  flatbuffers::Offset<KeyValueObject> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<KeyValueObject>(end);
    fbb_.Required(o, KeyValueObject::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueObject> CreateKeyValueObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  KeyValueObjectBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValueObject> CreateKeyValueObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  return iroha::api::CreateKeyValueObject(
      _fbb,
      key ? _fbb.CreateString(key) : 0,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

/////////////////////////////////////
/// Permissions
struct UserPermissionRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEDGER_ADD = 4,
    VT_LEDGER_REMOVE = 6
  };
  bool ledger_add() const {
    return GetField<uint8_t>(VT_LEDGER_ADD, 0) != 0;
  }
  bool ledger_remove() const {
    return GetField<uint8_t>(VT_LEDGER_REMOVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LEDGER_ADD) &&
           VerifyField<uint8_t>(verifier, VT_LEDGER_REMOVE) &&
           verifier.EndTable();
  }
};

struct UserPermissionRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ledger_add(bool ledger_add) {
    fbb_.AddElement<uint8_t>(UserPermissionRoot::VT_LEDGER_ADD, static_cast<uint8_t>(ledger_add), 0);
  }
  void add_ledger_remove(bool ledger_remove) {
    fbb_.AddElement<uint8_t>(UserPermissionRoot::VT_LEDGER_REMOVE, static_cast<uint8_t>(ledger_remove), 0);
  }
  UserPermissionRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserPermissionRootBuilder &operator=(const UserPermissionRootBuilder &);
  flatbuffers::Offset<UserPermissionRoot> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<UserPermissionRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserPermissionRoot> CreateUserPermissionRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool ledger_add = false,
    bool ledger_remove = false) {
  UserPermissionRootBuilder builder_(_fbb);
  builder_.add_ledger_remove(ledger_remove);
  builder_.add_ledger_add(ledger_add);
  return builder_.Finish();
}

struct UserPermissionLedger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEDGER_NAME = 4,
    VT_DOMAIN_ADD = 6,
    VT_DOMAIN_REMOVE = 8,
    VT_PEER_ADD = 10,
    VT_PEER_REMOVE = 12,
    VT_USER_ADD = 14,
    VT_USER_REMOVE = 16,
    VT_USER_GIVE_PERMISSION = 18
  };
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool KeyCompareLessThan(const UserPermissionLedger *o) const {
    return *ledger_name() < *o->ledger_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(ledger_name()->c_str(), val);
  }
  bool domain_add() const {
    return GetField<uint8_t>(VT_DOMAIN_ADD, 0) != 0;
  }
  bool domain_remove() const {
    return GetField<uint8_t>(VT_DOMAIN_REMOVE, 0) != 0;
  }
  bool peer_add() const {
    return GetField<uint8_t>(VT_PEER_ADD, 0) != 0;
  }
  bool peer_remove() const {
    return GetField<uint8_t>(VT_PEER_REMOVE, 0) != 0;
  }
  bool user_add() const {
    return GetField<uint8_t>(VT_USER_ADD, 0) != 0;
  }
  bool user_remove() const {
    return GetField<uint8_t>(VT_USER_REMOVE, 0) != 0;
  }
  bool user_give_permission() const {
    return GetField<uint8_t>(VT_USER_GIVE_PERMISSION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<uint8_t>(verifier, VT_DOMAIN_ADD) &&
           VerifyField<uint8_t>(verifier, VT_DOMAIN_REMOVE) &&
           VerifyField<uint8_t>(verifier, VT_PEER_ADD) &&
           VerifyField<uint8_t>(verifier, VT_PEER_REMOVE) &&
           VerifyField<uint8_t>(verifier, VT_USER_ADD) &&
           VerifyField<uint8_t>(verifier, VT_USER_REMOVE) &&
           VerifyField<uint8_t>(verifier, VT_USER_GIVE_PERMISSION) &&
           verifier.EndTable();
  }
};

struct UserPermissionLedgerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(UserPermissionLedger::VT_LEDGER_NAME, ledger_name);
  }
  void add_domain_add(bool domain_add) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_DOMAIN_ADD, static_cast<uint8_t>(domain_add), 0);
  }
  void add_domain_remove(bool domain_remove) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_DOMAIN_REMOVE, static_cast<uint8_t>(domain_remove), 0);
  }
  void add_peer_add(bool peer_add) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_PEER_ADD, static_cast<uint8_t>(peer_add), 0);
  }
  void add_peer_remove(bool peer_remove) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_PEER_REMOVE, static_cast<uint8_t>(peer_remove), 0);
  }
  void add_user_add(bool user_add) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_USER_ADD, static_cast<uint8_t>(user_add), 0);
  }
  void add_user_remove(bool user_remove) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_USER_REMOVE, static_cast<uint8_t>(user_remove), 0);
  }
  void add_user_give_permission(bool user_give_permission) {
    fbb_.AddElement<uint8_t>(UserPermissionLedger::VT_USER_GIVE_PERMISSION, static_cast<uint8_t>(user_give_permission), 0);
  }
  UserPermissionLedgerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserPermissionLedgerBuilder &operator=(const UserPermissionLedgerBuilder &);
  flatbuffers::Offset<UserPermissionLedger> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<UserPermissionLedger>(end);
    fbb_.Required(o, UserPermissionLedger::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<UserPermissionLedger> CreateUserPermissionLedger(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    bool domain_add = false,
    bool domain_remove = false,
    bool peer_add = false,
    bool peer_remove = false,
    bool user_add = false,
    bool user_remove = false,
    bool user_give_permission = false) {
  UserPermissionLedgerBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_user_give_permission(user_give_permission);
  builder_.add_user_remove(user_remove);
  builder_.add_user_add(user_add);
  builder_.add_peer_remove(peer_remove);
  builder_.add_peer_add(peer_add);
  builder_.add_domain_remove(domain_remove);
  builder_.add_domain_add(domain_add);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserPermissionLedger> CreateUserPermissionLedgerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ledger_name = nullptr,
    bool domain_add = false,
    bool domain_remove = false,
    bool peer_add = false,
    bool peer_remove = false,
    bool user_add = false,
    bool user_remove = false,
    bool user_give_permission = false) {
  return iroha::api::CreateUserPermissionLedger(
      _fbb,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      domain_add,
      domain_remove,
      peer_add,
      peer_remove,
      user_add,
      user_remove,
      user_give_permission);
}

struct UserPermissionDomain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DOMAIN_NAME = 4,
    VT_LEDGER_NAME = 6,
    VT_USER_GIVE_PERMISSION = 8,
    VT_USER_ADD = 10,
    VT_USER_REMOVE = 12
  };
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  bool KeyCompareLessThan(const UserPermissionDomain *o) const {
    return *domain_name() < *o->domain_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(domain_name()->c_str(), val);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool user_give_permission() const {
    return GetField<uint8_t>(VT_USER_GIVE_PERMISSION, 0) != 0;
  }
  bool user_add() const {
    return GetField<uint8_t>(VT_USER_ADD, 0) != 0;
  }
  bool user_remove() const {
    return GetField<uint8_t>(VT_USER_REMOVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<uint8_t>(verifier, VT_USER_GIVE_PERMISSION) &&
           VerifyField<uint8_t>(verifier, VT_USER_ADD) &&
           VerifyField<uint8_t>(verifier, VT_USER_REMOVE) &&
           verifier.EndTable();
  }
};

struct UserPermissionDomainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(UserPermissionDomain::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(UserPermissionDomain::VT_LEDGER_NAME, ledger_name);
  }
  void add_user_give_permission(bool user_give_permission) {
    fbb_.AddElement<uint8_t>(UserPermissionDomain::VT_USER_GIVE_PERMISSION, static_cast<uint8_t>(user_give_permission), 0);
  }
  void add_user_add(bool user_add) {
    fbb_.AddElement<uint8_t>(UserPermissionDomain::VT_USER_ADD, static_cast<uint8_t>(user_add), 0);
  }
  void add_user_remove(bool user_remove) {
    fbb_.AddElement<uint8_t>(UserPermissionDomain::VT_USER_REMOVE, static_cast<uint8_t>(user_remove), 0);
  }
  UserPermissionDomainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserPermissionDomainBuilder &operator=(const UserPermissionDomainBuilder &);
  flatbuffers::Offset<UserPermissionDomain> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<UserPermissionDomain>(end);
    fbb_.Required(o, UserPermissionDomain::VT_DOMAIN_NAME);
    fbb_.Required(o, UserPermissionDomain::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<UserPermissionDomain> CreateUserPermissionDomain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    bool user_give_permission = false,
    bool user_add = false,
    bool user_remove = false) {
  UserPermissionDomainBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_user_remove(user_remove);
  builder_.add_user_add(user_add);
  builder_.add_user_give_permission(user_give_permission);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserPermissionDomain> CreateUserPermissionDomainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    bool user_give_permission = false,
    bool user_add = false,
    bool user_remove = false) {
  return iroha::api::CreateUserPermissionDomain(
      _fbb,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      user_give_permission,
      user_add,
      user_remove);
}

struct UserPermissionAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_TRANSFER = 10,
    VT_ADD = 12,
    VT_REMOVE = 14,
    VT_CREATE = 16
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  bool KeyCompareLessThan(const UserPermissionAsset *o) const {
    return *asset_name() < *o->asset_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(asset_name()->c_str(), val);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool transfer() const {
    return GetField<uint8_t>(VT_TRANSFER, 0) != 0;
  }
  bool add() const {
    return GetField<uint8_t>(VT_ADD, 0) != 0;
  }
  bool remove() const {
    return GetField<uint8_t>(VT_REMOVE, 0) != 0;
  }
  bool create() const {
    return GetField<uint8_t>(VT_CREATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<uint8_t>(verifier, VT_TRANSFER) &&
           VerifyField<uint8_t>(verifier, VT_ADD) &&
           VerifyField<uint8_t>(verifier, VT_REMOVE) &&
           VerifyField<uint8_t>(verifier, VT_CREATE) &&
           verifier.EndTable();
  }
};

struct UserPermissionAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(UserPermissionAsset::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(UserPermissionAsset::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(UserPermissionAsset::VT_LEDGER_NAME, ledger_name);
  }
  void add_transfer(bool transfer) {
    fbb_.AddElement<uint8_t>(UserPermissionAsset::VT_TRANSFER, static_cast<uint8_t>(transfer), 0);
  }
  void add_add(bool add) {
    fbb_.AddElement<uint8_t>(UserPermissionAsset::VT_ADD, static_cast<uint8_t>(add), 0);
  }
  void add_remove(bool remove) {
    fbb_.AddElement<uint8_t>(UserPermissionAsset::VT_REMOVE, static_cast<uint8_t>(remove), 0);
  }
  void add_create(bool create) {
    fbb_.AddElement<uint8_t>(UserPermissionAsset::VT_CREATE, static_cast<uint8_t>(create), 0);
  }
  UserPermissionAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserPermissionAssetBuilder &operator=(const UserPermissionAssetBuilder &);
  flatbuffers::Offset<UserPermissionAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<UserPermissionAsset>(end);
    fbb_.Required(o, UserPermissionAsset::VT_ASSET_NAME);
    fbb_.Required(o, UserPermissionAsset::VT_DOMAIN_NAME);
    fbb_.Required(o, UserPermissionAsset::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<UserPermissionAsset> CreateUserPermissionAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    bool transfer = false,
    bool add = false,
    bool remove = false,
    bool create = false) {
  UserPermissionAssetBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  builder_.add_create(create);
  builder_.add_remove(remove);
  builder_.add_add(add);
  builder_.add_transfer(transfer);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserPermissionAsset> CreateUserPermissionAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    bool transfer = false,
    bool add = false,
    bool remove = false,
    bool create = false) {
  return iroha::api::CreateUserPermissionAsset(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      transfer,
      add,
      remove,
      create);
}

/////////////////////////////////////
/// Peer
struct Peer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_IP = 6,
    VT_TRUST = 8,
    VT_ACTIVE = 10,
    VT_JOIN_NETWORK = 12,
    VT_JOIN_VALIDATION = 14
  };
  const PublicKey *publicKey() const {
    return GetPointer<const PublicKey *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  double trust() const {
    return GetField<double>(VT_TRUST, 0.0);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool join_network() const {
    return GetField<uint8_t>(VT_JOIN_NETWORK, 0) != 0;
  }
  bool join_validation() const {
    return GetField<uint8_t>(VT_JOIN_VALIDATION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.VerifyTable(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IP) &&
           verifier.Verify(ip()) &&
           VerifyField<double>(verifier, VT_TRUST) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_JOIN_NETWORK) &&
           VerifyField<uint8_t>(verifier, VT_JOIN_VALIDATION) &&
           verifier.EndTable();
  }
};

struct PeerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<PublicKey> publicKey) {
    fbb_.AddOffset(Peer::VT_PUBLICKEY, publicKey);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(Peer::VT_IP, ip);
  }
  void add_trust(double trust) {
    fbb_.AddElement<double>(Peer::VT_TRUST, trust, 0.0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Peer::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_join_network(bool join_network) {
    fbb_.AddElement<uint8_t>(Peer::VT_JOIN_NETWORK, static_cast<uint8_t>(join_network), 0);
  }
  void add_join_validation(bool join_validation) {
    fbb_.AddElement<uint8_t>(Peer::VT_JOIN_VALIDATION, static_cast<uint8_t>(join_validation), 0);
  }
  PeerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerBuilder &operator=(const PeerBuilder &);
  flatbuffers::Offset<Peer> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Peer>(end);
    fbb_.Required(o, Peer::VT_PUBLICKEY);
    return o;
  }
};

inline flatbuffers::Offset<Peer> CreatePeer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    double trust = 0.0,
    bool active = false,
    bool join_network = false,
    bool join_validation = false) {
  PeerBuilder builder_(_fbb);
  builder_.add_trust(trust);
  builder_.add_ip(ip);
  builder_.add_publicKey(publicKey);
  builder_.add_join_validation(join_validation);
  builder_.add_join_network(join_network);
  builder_.add_active(active);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer> CreatePeerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> publicKey = 0,
    const char *ip = nullptr,
    double trust = 0.0,
    bool active = false,
    bool join_network = false,
    bool join_validation = false) {
  return iroha::api::CreatePeer(
      _fbb,
      publicKey,
      ip ? _fbb.CreateString(ip) : 0,
      trust,
      active,
      join_network,
      join_validation);
}

/////////////////////////////////////
struct Signature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6,
    VT_TIMESTAMP = 8
  };
  const PublicKey *publicKey() const {
    return GetPointer<const PublicKey *>(VT_PUBLICKEY);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.VerifyTable(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct SignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<PublicKey> publicKey) {
    fbb_.AddOffset(Signature::VT_PUBLICKEY, publicKey);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(Signature::VT_SIGNATURE, signature);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Signature::VT_TIMESTAMP, timestamp, 0);
  }
  SignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignatureBuilder &operator=(const SignatureBuilder &);
  flatbuffers::Offset<Signature> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Signature>(end);
    return o;
  }
};

inline flatbuffers::Offset<Signature> CreateSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> publicKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    uint64_t timestamp = 0) {
  SignatureBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Signature> CreateSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> publicKey = 0,
    const std::vector<uint8_t> *signature = nullptr,
    uint64_t timestamp = 0) {
  return iroha::api::CreateSignature(
      _fbb,
      publicKey,
      signature ? _fbb.CreateVector<uint8_t>(*signature) : 0,
      timestamp);
}

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CREATORPUBKEY = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_SIGNATURES = 10,
    VT_HASH = 12,
    VT_ATTACHMENT = 14
  };
  const PublicKey *creatorPubKey() const {
    return GetPointer<const PublicKey *>(VT_CREATORPUBKEY);
  }
  Command command_type() const {
    return static_cast<Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const AddAsset *command_as_AddAsset() const {
    return (command_type() == Command::AddAsset)? static_cast<const AddAsset *>(command()) : nullptr;
  }
  const RemoveAsset *command_as_RemoveAsset() const {
    return (command_type() == Command::RemoveAsset)? static_cast<const RemoveAsset *>(command()) : nullptr;
  }
  const CreateAsset *command_as_CreateAsset() const {
    return (command_type() == Command::CreateAsset)? static_cast<const CreateAsset *>(command()) : nullptr;
  }
  const Transfer *command_as_Transfer() const {
    return (command_type() == Command::Transfer)? static_cast<const Transfer *>(command()) : nullptr;
  }
  const Add *command_as_Add() const {
    return (command_type() == Command::Add)? static_cast<const Add *>(command()) : nullptr;
  }
  const Remove *command_as_Remove() const {
    return (command_type() == Command::Remove)? static_cast<const Remove *>(command()) : nullptr;
  }
  const Execute *command_as_Execute() const {
    return (command_type() == Command::Execute)? static_cast<const Execute *>(command()) : nullptr;
  }
  const Store *command_as_Store() const {
    return (command_type() == Command::Store)? static_cast<const Store *>(command()) : nullptr;
  }
  const SetPeerTrust *command_as_SetPeerTrust() const {
    return (command_type() == Command::SetPeerTrust)? static_cast<const SetPeerTrust *>(command()) : nullptr;
  }
  const ChangePeerTrust *command_as_ChangePeerTrust() const {
    return (command_type() == Command::ChangePeerTrust)? static_cast<const ChangePeerTrust *>(command()) : nullptr;
  }
  const SetPeerActive *command_as_SetPeerActive() const {
    return (command_type() == Command::SetPeerActive)? static_cast<const SetPeerActive *>(command()) : nullptr;
  }
  const SetChaincode *command_as_SetChaincode() const {
    return (command_type() == Command::SetChaincode)? static_cast<const SetChaincode *>(command()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Signature>> *signatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Signature>> *>(VT_SIGNATURES);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const Attachment *attachment() const {
    return GetPointer<const Attachment *>(VT_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CREATORPUBKEY) &&
           verifier.VerifyTable(creatorPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATURES) &&
           verifier.Verify(signatures()) &&
           verifier.VerifyVectorOfTables(signatures()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTACHMENT) &&
           verifier.VerifyTable(attachment()) &&
           verifier.EndTable();
  }
};

template<> inline const AddAsset *Transaction::command_as<AddAsset>() const {
  return command_as_AddAsset();
}

template<> inline const RemoveAsset *Transaction::command_as<RemoveAsset>() const {
  return command_as_RemoveAsset();
}

template<> inline const CreateAsset *Transaction::command_as<CreateAsset>() const {
  return command_as_CreateAsset();
}

template<> inline const Transfer *Transaction::command_as<Transfer>() const {
  return command_as_Transfer();
}

template<> inline const Add *Transaction::command_as<Add>() const {
  return command_as_Add();
}

template<> inline const Remove *Transaction::command_as<Remove>() const {
  return command_as_Remove();
}

template<> inline const Execute *Transaction::command_as<Execute>() const {
  return command_as_Execute();
}

template<> inline const Store *Transaction::command_as<Store>() const {
  return command_as_Store();
}

template<> inline const SetPeerTrust *Transaction::command_as<SetPeerTrust>() const {
  return command_as_SetPeerTrust();
}

template<> inline const ChangePeerTrust *Transaction::command_as<ChangePeerTrust>() const {
  return command_as_ChangePeerTrust();
}

template<> inline const SetPeerActive *Transaction::command_as<SetPeerActive>() const {
  return command_as_SetPeerActive();
}

template<> inline const SetChaincode *Transaction::command_as<SetChaincode>() const {
  return command_as_SetChaincode();
}

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_creatorPubKey(flatbuffers::Offset<PublicKey> creatorPubKey) {
    fbb_.AddOffset(Transaction::VT_CREATORPUBKEY, creatorPubKey);
  }
  void add_command_type(Command command_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Transaction::VT_COMMAND, command);
  }
  void add_signatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Signature>>> signatures) {
    fbb_.AddOffset(Transaction::VT_SIGNATURES, signatures);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(Transaction::VT_HASH, hash);
  }
  void add_attachment(flatbuffers::Offset<Attachment> attachment) {
    fbb_.AddOffset(Transaction::VT_ATTACHMENT, attachment);
  }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Transaction>(end);
    fbb_.Required(o, Transaction::VT_CREATORPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> creatorPubKey = 0,
    Command command_type = Command::NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Signature>>> signatures = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<Attachment> attachment = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_attachment(attachment);
  builder_.add_hash(hash);
  builder_.add_signatures(signatures);
  builder_.add_command(command);
  builder_.add_creatorPubKey(creatorPubKey);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PublicKey> creatorPubKey = 0,
    Command command_type = Command::NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<Signature>> *signatures = nullptr,
    const std::vector<uint8_t> *hash = nullptr,
    flatbuffers::Offset<Attachment> attachment = 0) {
  return iroha::api::CreateTransaction(
      _fbb,
      creatorPubKey,
      command_type,
      command,
      signatures ? _fbb.CreateVector<flatbuffers::Offset<Signature>>(*signatures) : 0,
      hash ? _fbb.CreateVector<uint8_t>(*hash) : 0,
      attachment);
}

struct Attachment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *mime() const {
    return GetPointer<const flatbuffers::String *>(VT_MIME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MIME) &&
           verifier.Verify(mime()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct AttachmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mime(flatbuffers::Offset<flatbuffers::String> mime) {
    fbb_.AddOffset(Attachment::VT_MIME, mime);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Attachment::VT_DATA, data);
  }
  AttachmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentBuilder &operator=(const AttachmentBuilder &);
  flatbuffers::Offset<Attachment> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Attachment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attachment> CreateAttachment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mime = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AttachmentBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_mime(mime);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attachment> CreateAttachmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  return iroha::api::CreateAttachment(
      _fbb,
      mime ? _fbb.CreateString(mime) : 0,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type) {
  switch (type) {
    case Object::NONE: {
      return true;
    }
    case Object::Peer: {
      auto ptr = reinterpret_cast<const Peer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object::Account: {
      auto ptr = reinterpret_cast<const Account *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object::Chaincode: {
      auto ptr = reinterpret_cast<const Chaincode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObject(
        verifier,  values->Get(i), types->GetEnum<Object>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyAsset(flatbuffers::Verifier &verifier, const void *obj, AnyAsset type) {
  switch (type) {
    case AnyAsset::NONE: {
      return true;
    }
    case AnyAsset::Asset: {
      auto ptr = reinterpret_cast<const Asset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyAsset::Currency: {
      auto ptr = reinterpret_cast<const Currency *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyAssetVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyAsset(
        verifier,  values->Get(i), types->GetEnum<AnyAsset>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command::NONE: {
      return true;
    }
    case Command::AddAsset: {
      auto ptr = reinterpret_cast<const AddAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::RemoveAsset: {
      auto ptr = reinterpret_cast<const RemoveAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::CreateAsset: {
      auto ptr = reinterpret_cast<const CreateAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Transfer: {
      auto ptr = reinterpret_cast<const Transfer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Remove: {
      auto ptr = reinterpret_cast<const Remove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Execute: {
      auto ptr = reinterpret_cast<const Execute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::Store: {
      auto ptr = reinterpret_cast<const Store *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::SetPeerTrust: {
      auto ptr = reinterpret_cast<const SetPeerTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::ChangePeerTrust: {
      auto ptr = reinterpret_cast<const ChangePeerTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::SetPeerActive: {
      auto ptr = reinterpret_cast<const SetPeerActive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::SetChaincode: {
      auto ptr = reinterpret_cast<const SetChaincode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyUserPermission(flatbuffers::Verifier &verifier, const void *obj, UserPermission type) {
  switch (type) {
    case UserPermission::NONE: {
      return true;
    }
    case UserPermission::UserPermissionRoot: {
      auto ptr = reinterpret_cast<const UserPermissionRoot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserPermission::UserPermissionLedger: {
      auto ptr = reinterpret_cast<const UserPermissionLedger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserPermission::UserPermissionDomain: {
      auto ptr = reinterpret_cast<const UserPermissionDomain *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserPermission::UserPermissionAsset: {
      auto ptr = reinterpret_cast<const UserPermissionAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyUserPermissionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserPermission(
        verifier,  values->Get(i), types->GetEnum<UserPermission>(i))) {
      return false;
    }
  }
  return true;
}

inline const iroha::api::ConsensusEvent *GetConsensusEvent(const void *buf) {
  return flatbuffers::GetRoot<iroha::api::ConsensusEvent>(buf);
}

inline const char *ConsensusEventIdentifier() {
  return "IROH";
}

inline bool ConsensusEventBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ConsensusEventIdentifier());
}

inline bool VerifyConsensusEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<iroha::api::ConsensusEvent>(ConsensusEventIdentifier());
}

inline const char *ConsensusEventExtension() {
  return "iroha";
}

inline void FinishConsensusEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<iroha::api::ConsensusEvent> root) {
  fbb.Finish(root, ConsensusEventIdentifier());
}

}  // namespace api
}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_API_IROHA_API_H_

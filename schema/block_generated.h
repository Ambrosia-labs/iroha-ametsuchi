// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLOCK_IROHA_H_
#define FLATBUFFERS_GENERATED_BLOCK_IROHA_H_

#include "flatbuffers/flatbuffers.h"

namespace iroha {

struct Block;

struct Transaction;

struct Signature;

struct Block FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TXS = 4,
    VT_PEER_SIGS = 6,
    VT_PREV_HASH = 8,
    VT_LENGTH = 10,
    VT_MERKLE_ROOT = 12,
    VT_HEIGHT = 14,
    VT_CREATED = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *txs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TXS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Transaction>> *mutable_txs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TXS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Signature>> *peer_sigs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Signature>> *>(VT_PEER_SIGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Signature>> *mutable_peer_sigs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Signature>> *>(VT_PEER_SIGS);
  }
  const flatbuffers::Vector<uint8_t> *prev_hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PREV_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_prev_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PREV_HASH);
  }
  uint32_t length() const {
    return GetField<uint32_t>(VT_LENGTH, 0);
  }
  bool mutate_length(uint32_t _length) {
    return SetField<uint32_t>(VT_LENGTH, _length, 0);
  }
  const flatbuffers::Vector<uint8_t> *merkle_root() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MERKLE_ROOT);
  }
  flatbuffers::Vector<uint8_t> *mutable_merkle_root() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MERKLE_ROOT);
  }
  uint64_t height() const {
    return GetField<uint64_t>(VT_HEIGHT, 0);
  }
  bool mutate_height(uint64_t _height) {
    return SetField<uint64_t>(VT_HEIGHT, _height, 0);
  }
  const flatbuffers::Vector<uint8_t> *created() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CREATED);
  }
  flatbuffers::Vector<uint8_t> *mutable_created() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CREATED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TXS) &&
           verifier.Verify(txs()) &&
           verifier.VerifyVectorOfTables(txs()) &&
           VerifyOffset(verifier, VT_PEER_SIGS) &&
           verifier.Verify(peer_sigs()) &&
           verifier.VerifyVectorOfTables(peer_sigs()) &&
           VerifyOffset(verifier, VT_PREV_HASH) &&
           verifier.Verify(prev_hash()) &&
           VerifyField<uint32_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_MERKLE_ROOT) &&
           verifier.Verify(merkle_root()) &&
           VerifyField<uint64_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_CREATED) &&
           verifier.Verify(created()) &&
           verifier.EndTable();
  }
};

struct BlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_txs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> txs) {
    fbb_.AddOffset(Block::VT_TXS, txs);
  }
  void add_peer_sigs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Signature>>> peer_sigs) {
    fbb_.AddOffset(Block::VT_PEER_SIGS, peer_sigs);
  }
  void add_prev_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prev_hash) {
    fbb_.AddOffset(Block::VT_PREV_HASH, prev_hash);
  }
  void add_length(uint32_t length) {
    fbb_.AddElement<uint32_t>(Block::VT_LENGTH, length, 0);
  }
  void add_merkle_root(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> merkle_root) {
    fbb_.AddOffset(Block::VT_MERKLE_ROOT, merkle_root);
  }
  void add_height(uint64_t height) {
    fbb_.AddElement<uint64_t>(Block::VT_HEIGHT, height, 0);
  }
  void add_created(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> created) {
    fbb_.AddOffset(Block::VT_CREATED, created);
  }
  BlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockBuilder &operator=(const BlockBuilder &);
  flatbuffers::Offset<Block> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<Block>(end);
    return o;
  }
};

inline flatbuffers::Offset<Block> CreateBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> txs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Signature>>> peer_sigs = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prev_hash = 0,
    uint32_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> merkle_root = 0,
    uint64_t height = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> created = 0) {
  BlockBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_created(created);
  builder_.add_merkle_root(merkle_root);
  builder_.add_length(length);
  builder_.add_prev_hash(prev_hash);
  builder_.add_peer_sigs(peer_sigs);
  builder_.add_txs(txs);
  return builder_.Finish();
}

inline flatbuffers::Offset<Block> CreateBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *txs = nullptr,
    const std::vector<flatbuffers::Offset<Signature>> *peer_sigs = nullptr,
    const std::vector<uint8_t> *prev_hash = nullptr,
    uint32_t length = 0,
    const std::vector<uint8_t> *merkle_root = nullptr,
    uint64_t height = 0,
    const std::vector<uint8_t> *created = nullptr) {
  return iroha::CreateBlock(
      _fbb,
      txs ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*txs) : 0,
      peer_sigs ? _fbb.CreateVector<flatbuffers::Offset<Signature>>(*peer_sigs) : 0,
      prev_hash ? _fbb.CreateVector<uint8_t>(*prev_hash) : 0,
      length,
      merkle_root ? _fbb.CreateVector<uint8_t>(*merkle_root) : 0,
      height,
      created ? _fbb.CreateVector<uint8_t>(*created) : 0);
}

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Transaction>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransactionBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Signature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignatureBuilder &operator=(const SignatureBuilder &);
  flatbuffers::Offset<Signature> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Signature>(end);
    return o;
  }
};

inline flatbuffers::Offset<Signature> CreateSignature(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SignatureBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_BLOCK_IROHA_H_
